import { spawnSync } from "child_process";
import { existsSync, mkdirSync } from "fs";
import { join, relative, resolve } from "path";
import { checksum, commandIsInPath, findFiles, pluralize } from "./utils.js";
let logger;
function initLogger(name) {
    const prefix = `[${name}] `;
    logger = {
        info: (str) => console.info(prefix, str),
        warn: (str) => console.warn(prefix, str),
        error: (str) => console.error(prefix, str),
    };
}
function onCliError(error, statusCode) {
    logger.error("Protobuf Compiler Error: \n");
    console.error(error);
    if (statusCode !== 0) {
        console.error();
        console.error("No .pb.ts files were created or updated.");
    }
    process.exit(statusCode);
}
function getConfigFilePath() {
    const cwd = process.cwd();
    for (const ext of [".js", ".mjs", ".cjs"]) {
        const path = join(cwd, "proto.config") + ext;
        if (existsSync(path)) {
            return path;
        }
    }
}
async function getConfig() {
    const projectRoot = process.cwd();
    const defaultConfig = {
        root: projectRoot,
        exclude: [],
        dest: ".",
        language: existsSync(join(projectRoot, "tsconfig.json"))
            ? "typescript"
            : "javascript",
        json: {},
        typescript: {},
    };
    const configFilePath = getConfigFilePath();
    let userConfig = {};
    if (configFilePath) {
        logger.info(`Using configuration file at '${configFilePath}'.`);
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
            userConfig = (await import(configFilePath)).default;
        }
        catch (e) {
            logger.error(`Failed to parse configuration file.`);
            console.log(e);
            process.exit(1);
        }
        const unknownKeys = Object.keys(userConfig).filter((key) => !(key in defaultConfig));
        if (unknownKeys.length) {
            logger.warn(`Found unknown configuration options: ${unknownKeys
                .map((k) => `'${k}'`)
                .join(", ")}.`);
        }
    }
    return {
        ...defaultConfig,
        ...userConfig,
    };
}
export async function main(opts) {
    initLogger(opts.logger?.name ?? "ProtoScript");
    const config = await getConfig();
    const excludes = config.exclude.map((pattern) => RegExp(pattern));
    const protos = findFiles(config.root, ".proto")
        .map((filepath) => relative(config.root, filepath))
        .filter((file) => !excludes.some((exclude) => exclude.exec(file)));
    if (!commandIsInPath("protoc")) {
        logger.error(`Could not find the protobuf compiler. Please make sure 'protoc' is installed and in your '$PATH'.

  MacOS:
    \`brew install protobuf\`

  Linux:
    \`apt install -y protobuf-compiler\` 

  Windows:
    \`choco install protoc\`

  Or install from a precompiled binary:
    https://github.com/protocolbuffers/protobuf/releases
`);
        process.exit(1);
    }
    if (protos.length === 0) {
        logger.info("No '.proto' files found.");
        process.exit(0);
    }
    try {
        const destination = config.dest === "." ? "." : resolve(config.dest);
        if (!existsSync(destination)) {
            logger.info(`Created destination folder '${destination}'.`);
            mkdirSync(destination, { recursive: true });
        }
        process.chdir(config.root);
        const protoExt = config.language === "typescript" ? "pb.ts" : "pb.js";
        const protosBeforeCompile = Object.fromEntries(findFiles(destination, protoExt).map((file) => [file, checksum(file)]));
        const protoc = spawnSync(`\
protoc \
  --plugin=protoc-gen-protoscript=${opts.compiler.path} \
  --protoscript_out=${destination} \
  --protoscript_opt=language=${config.language} \
  ${config.json.emitFieldsWithDefaultValues
            ? "--protoscript_opt=json=emitFieldsWithDefaultValues"
            : ""} \
  ${config.json.useProtoFieldName
            ? "--protoscript_opt=json=useProtoFieldName"
            : ""} \
  ${config.typescript.emitDeclarationOnly
            ? "--protoscript_opt=typescript=emitDeclarationOnly"
            : ""} \
  ${protos.join(" ")}
`, { shell: true, encoding: "utf8" });
        if (protoc.stderr) {
            onCliError(protoc.stderr, protoc.status ?? 1);
        }
        const protosAfterCompile = findFiles(destination, protoExt).map((file) => [
            file,
            checksum(file),
        ]);
        const created = protosAfterCompile.filter((file) => !protosBeforeCompile[file[0]]);
        const updated = protosAfterCompile.filter((file) => protosBeforeCompile[file[0]] && protosBeforeCompile[file[0]] !== file[1]);
        const unchanged = protosAfterCompile.filter((file) => protosBeforeCompile[file[0]] === file[1]);
        logger.info("\n");
        if (created.length > 0) {
            console.info(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Created:\n${created.map((f) => `  - ${f[0]}`).join("\n")}\n`);
        }
        if (updated.length > 0) {
            console.info(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Updated:\n${updated.map((f) => `  - ${f[0]}`).join("\n")}\n`);
        }
        console.info(`${created.length} ${pluralize("file", created.length)} created, ${updated.length} ${pluralize("file", updated.length)} updated, ${unchanged.length} ${pluralize("file", unchanged.length)} unchanged. ${protos.length} ${pluralize("file", protos.length)} found.`);
    }
    catch (error) {
        onCliError(error, 1);
    }
}
