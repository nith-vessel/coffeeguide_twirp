export declare type UserConfig = Partial<Config>;
declare type Config = {
    /**
     * The root directory. `.proto` files will be searched under this directory, and `proto` import paths will be resolved relative to this directory. ProtoScript will recursively search all subdirectories for `.proto` files.
     *
     * Defaults to the project root.
     *
     * Example:
     *
     * If we have the following project structure:
     *
     * /src
     *   A.proto
     *   B.proto
     *
     * Default:
     *
     * A.proto would `import` B.proto as follows:
     *
     * ```proto
     * import "src/B.proto";
     * ```
     *
     * Setting `root` to `src`:
     *
     * // proto.config.mjs
     * ```js
     * // @type {import('protoscript').Config}
     * export default {
     *   root: "src"
     * }
     * ```
     *
     * A.proto would `import` B.proto as follows:
     *
     * ```proto
     * import "B.proto";
     * ```
     *
     * TypeScript projects will generally want to set this value to match their `rootDir`.
     */
    root: string;
    /**
     * An array of patterns that should be skipped when searching for `.proto` files.
     *
     * Example:
     *
     * If we have the following project structure:
     * /src
     *   /foo
     *     A.proto
     *   /bar
     *     B.proto
     *
     * Setting `exclude` to `["/bar/"]`:
     *
     * // proto.config.mjs
     * ```js
     * // @type {import('protoscript').Config}
     * export default {
     *   exclude: ["/bar/"]
     * }
     * ```
     *
     * Will only process A.proto (B.proto) will be excluded from ProtoScript's code generation.
     *
     */
    exclude: string[];
    /** The destination folder for generated files.
     *
     * Defaults to colocating generated files with the corresponding `proto` definition.
     * Example:
     *
     * If we have the following project structure:
     *
     * /src
     *   A.proto
     *   B.proto
     *
     * Default:
     *
     * ProtoScript will generate the following:
     *
     * /src
     *   A.proto
     *   A.pb.ts
     *   B.proto
     *   B.pb.ts
     *
     * Setting `dest` to `out`:
     *
     * // proto.config.mjs
     * ```js
     * // @type {import('protoscript').Config}
     * export default {
     *   dest: "out",
     * }
     *
     * /src
     *   A.proto
     *   B.proto
     * /out
     *   /src
     *     A.pb.ts
     *     B.pb.ts
     *
     * Note that the generated directory structure will mirror the `proto` paths exactly as is, only nested under the `dest` directory. If you want to change this, for instance, to omit `src` from the `out` directory above, you can set the `root`.
     *
     * Setting `root` to `src`:
     *
     * // proto.config.mjs
     * ```js
     * // @type {import('protoscript').Config}
     * export default {
     *   root: "src",
     *   dest: "out",
     * }
     *
     * /src
     *   A.proto
     *   B.proto
     * /out
     *   A.pb.ts
     *   B.pb.ts
     */
    dest: string;
    /**
     * Whether to generate JavaScript or TypeScript.
     *
     * If omitted, ProtoScript will attempt to autodetect the language by looking for a `tsconfig.json` in the project root. If found, ProtoScript will generate TypeScript, otherwise JavaScript.
     */
    language: "javascript" | "typescript";
    /**
     * JSON serializer options.
     *
     * See https://developers.google.com/protocol-buffers/docs/proto3#json for more context.
     */
    json: {
        /**
         * Fields with default values are omitted by default in proto3 JSON. Setting this to true will serialize fields with their default values.
         */
        emitFieldsWithDefaultValues?: boolean;
        /**
         * Field names are converted to lowerCamelCase by default in proto3 JSON. Setting this to true will use the proto field name as the JSON key when serializing JSON.
         *
         * Either way, Proto3 JSON parsers are required to accept both the converted lowerCamelCase name and the proto field name.
         */
        useProtoFieldName?: boolean;
    };
    /**
     * TypeScript options.
     */
    typescript: {
        /**
         * Only emit TypeScript type definitions.
         */
        emitDeclarationOnly?: boolean;
    };
};
interface CliOptions {
    compiler: {
        path: string;
    };
    logger?: {
        name: string;
    };
}
export declare function main(opts: CliOptions): Promise<void>;
export {};
