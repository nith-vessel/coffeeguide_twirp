import { ByteSource } from "./utils.js";
/**
 * BinaryDecoder implements the decoders for all the wire types specified in
 * https://developers.google.com/protocol-buffers/docs/encoding.
 */
export declare class BinaryDecoder {
    static instanceCache_: BinaryDecoder[];
    /**
     * Pops an instance off the instance cache, or creates one if the cache is
     * empty.
     */
    static alloc(opt_bytes: ByteSource | undefined, opt_start: number | undefined, opt_length: number | undefined): BinaryDecoder;
    bytes_: Uint8Array;
    start_: number;
    end_: number;
    cursor_: number;
    error_: boolean;
    constructor(opt_bytes: ByteSource | undefined, opt_start: number | undefined, opt_length: number | undefined);
    /**
     * Puts this instance back in the instance cache.
     */
    free(): void;
    /**
     * Makes a copy of this decoder.
     */
    clone(): BinaryDecoder;
    /**
     * Clears the decoder.
     */
    clear(): void;
    /**
     * Returns the raw buffer.
     */
    getBuffer(): Uint8Array | undefined;
    /**
     * Changes the block of bytes we're decoding.
     */
    setBlock(data: ByteSource, opt_start: number | undefined, opt_length: number | undefined): void;
    getEnd(): number;
    setEnd(end: number): void;
    /**
     * Moves the read cursor back to the start of the block.
     */
    reset(): void;
    /**
     * Returns the internal read cursor.
     */
    getCursor(): number;
    /**
     * Returns the internal read cursor.
     */
    setCursor(cursor: number): void;
    /**
     * Advances the stream cursor by the given number of bytes.
     */
    advance(count: number): void;
    /**
     * Returns true if this decoder is at the end of the block.
     */
    atEnd(): boolean;
    /**
     * Returns true if this decoder is at the end of the block.
     */
    pastEnd(): boolean;
    /**
     * Returns true if this decoder encountered an error due to corrupt data.
     */
    getError(): boolean;
    /**
     * Reads an unsigned varint from the binary stream and invokes the conversion
     * function with the value in two signed 32 bit integers to produce the result.
     * Since this does not convert the value to a number, no precision is lost.
     *
     * It's possible for an unsigned varint to be incorrectly encoded - more than
     * 64 bits' worth of data could be present. If this happens, this method will
     * throw an error.
     *
     * Decoding varints requires doing some funny base-128 math - for more
     * details on the format, see
     * https://developers.google.com/protocol-buffers/docs/encoding
     */
    readSplitVarint64<T>(convert: (a: number, b: number) => T): T;
    /**
     * Reads a 64-bit fixed-width value from the stream and invokes the conversion
     * function with the value in two signed 32 bit integers to produce the result.
     * Since this does not convert the value to a number, no precision is lost.
     */
    readSplitFixed64<T>(convert: (a: number, b: number) => T): T;
    /**
     * Skips over a varint in the block without decoding it.
     */
    skipVarint(): void;
    /**
     * Skips backwards over a varint in the block - to do this correctly, we have
     * to know the value we're skipping backwards over or things are ambiguous.
     */
    unskipVarint(value: number): void;
    /**
     * Reads a 32-bit varint from the binary stream. Due to a quirk of the encoding
     * format and Javascript's handling of bitwise math, this actually works
     * correctly for both signed and unsigned 32-bit varints.
     *
     * This function is called vastly more frequently than any other in
     * BinaryDecoder, so it has been unrolled and tweaked for performance.
     *
     * If there are more than 32 bits of data in the varint, it _must_ be due to
     * sign-extension. If we're in debug mode and the high 32 bits don't match the
     * expected sign extension, this method will throw an error.
     *
     * Decoding varints requires doing some funny base-128 math - for more
     * details on the format, see
     * https://developers.google.com/protocol-buffers/docs/encoding
     *
     */
    readUnsignedVarint32(): number;
    /**
     * The readUnsignedVarint32 above deals with signed 32-bit varints correctly,
     * so this is just an alias.
     */
    readSignedVarint32(): number;
    /**
     * Reads a 32-bit unsigned variant and returns its value as a string.
     */
    readUnsignedVarint32String(): string;
    /**
     * Reads a 32-bit signed variant and returns its value as a string.
     */
    readSignedVarint32String(): string;
    /**
     * Reads a signed, zigzag-encoded 32-bit varint from the binary stream.
     *
     * Zigzag encoding is a modification of varint encoding that reduces the
     * storage overhead for small negative integers - for more details on the
     * format, see https://developers.google.com/protocol-buffers/docs/encoding
     */
    readZigzagVarint32(): number;
    /**
     * Reads an unsigned 64-bit varint from the binary stream. Note that since
     * Javascript represents all numbers as double-precision floats, there will be
     * precision lost if the absolute value of the varint is larger than 2^53.
     */
    readUnsignedVarint64(): number;
    /**
     * Reads an unsigned 64-bit varint from the binary stream and returns the value
     * as a decimal string.
     */
    readUnsignedVarint64String(): string;
    /**
     * Reads a signed 64-bit varint from the binary stream. Note that since
     * Javascript represents all numbers as double-precision floats, there will be
     * precision lost if the absolute value of the varint is larger than 2^53.
     */
    readSignedVarint64(): number;
    /**
     * Reads an signed 64-bit varint from the binary stream and returns the value
     * as a decimal string.
     */
    readSignedVarint64String(): string;
    /**
     * Reads a signed, zigzag-encoded 64-bit varint from the binary stream. Note
     * that since Javascript represents all numbers as double-precision floats,
     * there will be precision lost if the absolute value of the varint is larger
     * than 2^53.
     *
     * Zigzag encoding is a modification of varint encoding that reduces the
     * storage overhead for small negative integers - for more details on the
     * format, see https://developers.google.com/protocol-buffers/docs/encoding
     */
    readZigzagVarint64(): number;
    /**
     * Reads a signed zigzag encoded varint from the binary stream and invokes
     * the conversion function with the value in two signed 32 bit integers to
     * produce the result. Since this does not convert the value to a number, no
     * precision is lost.
     *
     * It's possible for an unsigned varint to be incorrectly encoded - more than
     * 64 bits' worth of data could be present. If this happens, this method will
     * throw an error.
     *
     * Zigzag encoding is a modification of varint encoding that reduces the
     * storage overhead for small negative integers - for more details on the
     * format, see https://developers.google.com/protocol-buffers/docs/encoding
     *     the result value, takes parameters (lowBits, highBits).
     */
    readSplitZigzagVarint64<T>(convert: (bitsLow: number, bitsHigh: number) => T): T;
    /**
     * Reads a signed, zigzag-encoded 64-bit varint from the binary stream
     * losslessly and returns it as an 8-character Unicode string for use as a hash
     * table key.
     *
     * Zigzag encoding is a modification of varint encoding that reduces the
     * storage overhead for small negative integers - for more details on the
     * format, see https://developers.google.com/protocol-buffers/docs/encoding
     */
    readZigzagVarintHash64(): string;
    /**
     * Reads a signed, zigzag-encoded 64-bit varint from the binary stream and
     * returns its value as a string.
     *
     * Zigzag encoding is a modification of varint encoding that reduces the
     * storage overhead for small negative integers - for more details on the
     * format, see https://developers.google.com/protocol-buffers/docs/encoding
     */
    readZigzagVarint64String(): string;
    /**
     * Reads a raw unsigned 8-bit integer from the binary stream.
     */
    readUint8(): number;
    /**
     * Reads a raw unsigned 16-bit integer from the binary stream.
     */
    readUint16(): number;
    /**
     * Reads a raw unsigned 32-bit integer from the binary stream.
     */
    readUint32(): number;
    /**
     * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
     * Javascript represents all numbers as double-precision floats, there will be
     * precision lost if the absolute value of the integer is larger than 2^53.
     */
    readUint64(): number;
    /**
     * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
     * Javascript represents all numbers as double-precision floats, there will be
     * precision lost if the absolute value of the integer is larger than 2^53.
     */
    readUint64String(): string;
    /**
     * Reads a raw signed 8-bit integer from the binary stream.
     */
    readInt8(): number;
    /**
     * Reads a raw signed 16-bit integer from the binary stream.
     */
    readInt16(): number;
    /**
     * Reads a raw signed 32-bit integer from the binary stream.
     */
    readInt32(): number;
    /**
     * Reads a raw signed 64-bit integer from the binary stream. Note that since
     * Javascript represents all numbers as double-precision floats, there will be
     * precision lost if the absolute value of the integer is larger than 2^53.
     */
    readInt64(): number;
    /**
     * Reads a raw signed 64-bit integer from the binary stream and returns it as a
     * string.
     */
    readInt64String(): string;
    /**
     * Reads a 32-bit floating-point number from the binary stream, using the
     * temporary buffer to realign the data.
     */
    readFloat(): number;
    /**
     * Reads a 64-bit floating-point number from the binary stream, using the
     * temporary buffer to realign the data.
     */
    readDouble(): number;
    /**
     * Reads a boolean value from the binary stream.
     */
    readBool(): boolean;
    /**
     * Reads an enum value from the binary stream, which are always encoded as
     * signed varints.
     */
    readEnum(): number;
    /**
     * Reads and parses a UTF-8 encoded unicode string from the stream.
     */
    readString(length: number): string;
    /**
     * Reads and parses a UTF-8 encoded unicode string (with length prefix) from
     * the stream.
     */
    readStringWithLength(): string;
    /**
     * Reads a block of raw bytes from the binary stream.
     */
    readBytes(length: number): Uint8Array;
    /**
     * Reads a 64-bit varint from the stream and returns it as an 8-character
     * Unicode string for use as a hash table key.
     */
    readVarintHash64(): string;
    /**
     * Reads a 64-bit fixed-width value from the stream and returns it as an
     * 8-character Unicode string for use as a hash table key.
     */
    readFixedHash64(): string;
}
