import { WireType, FieldType } from "./constants.js";
import { BinaryDecoder } from "./decoder.js";
import { ByteSource } from "./utils.js";
/**
 * BinaryReader implements the decoders for all the wire types specified in
 * https://developers.google.com/protocol-buffers/docs/encoding.
 */
export declare class BinaryReader {
    /**
     * Global pool of BinaryReader instances.
     */
    static instanceCache_: BinaryReader[];
    /**
     * Pops an instance off the instance cache, or creates one if the cache is
     * empty.
     */
    static alloc(opt_bytes?: ByteSource | undefined, opt_start?: number | undefined, opt_length?: number | undefined): BinaryReader;
    decoder_: BinaryDecoder;
    fieldCursor_: number;
    nextField_: number;
    nextWireType_: WireType;
    error_: boolean;
    readCallbacks_: Record<string, (reader: BinaryReader) => any>;
    constructor(opt_bytes?: ByteSource | undefined, opt_start?: number | undefined, opt_length?: number | undefined);
    /**
     * Puts this instance back in the instance cache.
     */
    free(): void;
    /**
     * Returns the cursor immediately before the current field's tag.
     */
    getFieldCursor(): number;
    /**
     * Returns the internal read cursor.
     */
    getCursor(): number;
    /**
     * Returns the raw buffer.
     */
    getBuffer(): Uint8Array | undefined;
    getFieldNumber(): number;
    /**
     * The wire type of the next field in the stream, or WireType.INVALID if there is no next field.
     */
    getWireType(): WireType;
    /**
     * Whether the current wire type is a delimited field. Used to
     * conditionally parse packed repeated fields.
     */
    isDelimited(): boolean;
    /**
     * Whether the current wire type is an end-group tag. Used as
     * an exit condition in decoder loops in generated code.
     */
    isEndGroup(): boolean;
    /**
     * Returns true if this reader hit an error due to corrupt data.
     */
    getError(): boolean;
    /**
     * Points this reader at a new block of bytes.
     */
    setBlock(bytes: Uint8Array, start: number, length: number): void;
    /**
     * Rewinds the stream cursor to the beginning of the buffer and resets all
     * internal state.
     */
    reset(): void;
    /**
     * Advances the stream cursor by the given number of bytes.
     */
    advance(count: number): void;
    /**
     * Reads the next field header in the stream if there is one, returns true if
     * we saw a valid field header or false if we've read the whole stream.
     * Throws an error if we encountered a deprecated START_GROUP/END_GROUP field.
     *
     * True if the stream contains more fields.
     */
    nextField(): boolean;
    /**
     * Winds the reader back to just before this field's header.
     */
    unskipHeader(): void;
    /**
     * Skips all contiguous fields whose header matches the one we just read.
     */
    skipMatchingFields(): void;
    /**
     * Skips over the next varint field in the binary stream.
     */
    skipVarintField(): void;
    /**
     * Skips over the next delimited field in the binary stream.
     */
    skipDelimitedField(): void;
    /**
     * Skips over the next fixed32 field in the binary stream.
     */
    skipFixed32Field(): void;
    /**
     * Skips over the next fixed64 field in the binary stream.
     */
    skipFixed64Field(): void;
    /**
     * Skips over the next group field in the binary stream.
     */
    skipGroup(): void;
    /**
     * Skips over the next field in the binary stream - this is useful if we're
     * decoding a message that contain unknown fields.
     */
    skipField(): void;
    /**
     * Registers a user-defined read callback.
     */
    registerReadCallback(callbackName: string, callback: (arg0: BinaryReader) => any): void;
    /**
     * Runs a registered read callback.
     */
    runReadCallback(callbackName: string): any;
    /**
     * Reads a field of any valid non-message type from the binary stream.
     */
    readAny(fieldType: FieldType): number | boolean | string | Uint8Array;
    /**
     * Deserialize a proto into the provided message object using the provided
     * reader function. This function is templated as we currently have one client
     * who is using manual deserialization instead of the code-generated versions.
     */
    readMessage<T>(message: T, reader: (arg0: T, arg1: BinaryReader) => any): void;
    /**
     * Deserialize a proto into the provided message object using the provided
     * reader function, assuming that the message is serialized as a group
     * with the given tag.
     */
    readGroup<T>(field: number, message: T, reader: (arg0: T, arg1: BinaryReader) => T): void;
    /**
     * Return a decoder that wraps the current delimited field.
     */
    getFieldDecoder(): BinaryDecoder;
    /**
     * Reads a signed 32-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readInt32(): number;
    /**
     * Reads a signed 32-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readInt32String(): string;
    /**
     * Reads a signed 64-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readInt64(): number;
    /**
     * Reads a signed 64-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     *
     * Returns the value as a string.
     */
    readInt64String(): string;
    /**
     * Reads an unsigned 32-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readUint32(): number;
    /**
     * Reads an unsigned 32-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     *
     * Returns the value as a string.
     */
    readUint32String(): string;
    /**
     * Reads an unsigned 64-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readUint64(): number;
    /**
     * Reads an unsigned 64-bit integer field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     *
     * Returns the value as a string.
     */
    readUint64String(): string;
    /**
     * Reads a signed zigzag-encoded 32-bit integer field from the binary stream,
     * or throws an error if the next field in the stream is not of the correct
     * wire type.
     */
    readSint32(): number;
    /**
     * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
     * or throws an error if the next field in the stream is not of the correct
     * wire type.
     */
    readSint64(): number;
    /**
     * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
     * or throws an error if the next field in the stream is not of the correct
     * wire type.
     */
    readSint64String(): string;
    /**
     * Reads an unsigned 32-bit fixed-length integer fiield from the binary stream,
     * or throws an error if the next field in the stream is not of the correct
     * wire type.
     */
    readFixed32(): number;
    /**
     * Reads an unsigned 64-bit fixed-length integer fiield from the binary stream,
     * or throws an error if the next field in the stream is not of the correct
     * wire type.
     */
    readFixed64(): number;
    /**
     * Reads a signed 64-bit integer field from the binary stream as a string, or
     * throws an error if the next field in the stream is not of the correct wire
     * type.
     *
     * Returns the value as a string.
     */
    readFixed64String(): string;
    /**
     * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or
     * throws an error if the next field in the stream is not of the correct wire
     * type.
     */
    readSfixed32(): number;
    /**
     * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or
     * throws an error if the next field in the stream is not of the correct wire
     * type.
     */
    readSfixed32String(): string;
    /**
     * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or
     * throws an error if the next field in the stream is not of the correct wire
     * type
     */
    readSfixed64(): number;
    /**
     * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or
     * throws an error if the next field in the stream is not of the correct wire
     * type.
     *
     * Returns the value as a string.
     */
    readSfixed64String(): string;
    /**
     * Reads a 32-bit floating-point field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readFloat(): number;
    /**
     * Reads a 64-bit floating-point field from the binary stream, or throws an
     * error if the next field in the stream is not of the correct wire type.
     */
    readDouble(): number;
    /**
     * Reads a boolean field from the binary stream, or throws an error if the next
     * field in the stream is not of the correct wire type.
     */
    readBool(): boolean;
    /**
     * Reads an enum field from the binary stream, or throws an error if the next
     * field in the stream is not of the correct wire type.
     */
    readEnum(): number;
    /**
     * Reads a string field from the binary stream, or throws an error if the next
     * field in the stream is not of the correct wire type.
     */
    readString(): string;
    /**
     * Reads a length-prefixed block of bytes from the binary stream, or returns
     * null if the next field in the stream has an invalid length value.
     */
    readBytes(): Uint8Array;
    /**
     * Reads a 64-bit varint or fixed64 field from the stream and returns it as an
     * 8-character Unicode string for use as a hash table key, or throws an error
     * if the next field in the stream is not of the correct wire type.
     */
    readVarintHash64(): string;
    /**
     * Reads an sint64 field from the stream and returns it as an 8-character
     * Unicode string for use as a hash table key, or throws an error if the next
     * field in the stream is not of the correct wire type.
     */
    readSintHash64(): string;
    /**
     * Reads a 64-bit varint field from the stream and invokes `convert` to produce
     * the return value, or throws an error if the next field in the stream is not
     * of the correct wire type.
     */
    readSplitVarint64<T>(convert: (arg0: number, arg1: number) => T): T;
    /**
     * Reads a 64-bit varint or fixed64 field from the stream and returns it as a
     * 8-character Unicode string for use as a hash table key, or throws an error
     * if the next field in the stream is not of the correct wire type.
     */
    readFixedHash64(): string;
    /**
     * Reads a 64-bit fixed64 field from the stream and invokes `convert`
     * to produce the return value, or throws an error if the next field in the
     * stream is not of the correct wire type.
     */
    readSplitFixed64<T>(convert: (arg0: number, arg1: number) => T): T;
    /**
     * Reads a packed scalar field using the supplied raw reader function.
     */
    readPackedField_<T>(decodeMethod: (this: BinaryDecoder) => T): Array<T>;
    /**
     * Reads a packed int32 field, which consists of a length header and a list of
     * signed varints.
     */
    readPackedInt32(): Array<number>;
    /**
     * Reads a packed int32 field, which consists of a length header and a list of
     * signed varints. Returns a list of strings.
     */
    readPackedInt32String(): Array<string>;
    /**
     * Reads a packed int64 field, which consists of a length header and a list of
     * signed varints.
     */
    readPackedInt64(): Array<number>;
    /**
     * Reads a packed int64 field, which consists of a length header and a list of
     * signed varints. Returns a list of strings.
     */
    readPackedInt64String(): Array<string>;
    /**
     * Reads a packed uint32 field, which consists of a length header and a list of
     * unsigned varints.
     */
    readPackedUint32(): Array<number>;
    /**
     * Reads a packed uint32 field, which consists of a length header and a list of
     * unsigned varints. Returns a list of strings.
     */
    readPackedUint32String(): Array<string>;
    /**
     * Reads a packed uint64 field, which consists of a length header and a list of
     * unsigned varints.
     */
    readPackedUint64(): Array<number>;
    /**
     * Reads a packed uint64 field, which consists of a length header and a list of
     * unsigned varints. Returns a list of strings.
     */
    readPackedUint64String(): Array<string>;
    /**
     * Reads a packed sint32 field, which consists of a length header and a list of
     * zigzag varints.
     */
    readPackedSint32(): Array<number>;
    /**
     * Reads a packed sint64 field, which consists of a length header and a list of
     * zigzag varints.
     */
    readPackedSint64(): Array<number>;
    /**
     * Reads a packed sint64 field, which consists of a length header and a list of
     * zigzag varints.  Returns a list of strings.
     */
    readPackedSint64String(): Array<string>;
    /**
     * Reads a packed fixed32 field, which consists of a length header and a list
     * of unsigned 32-bit ints.
     */
    readPackedFixed32(): Array<number>;
    /**
     * Reads a packed fixed64 field, which consists of a length header and a list
     * of unsigned 64-bit ints.
     */
    readPackedFixed64(): Array<number>;
    /**
     * Reads a packed fixed64 field, which consists of a length header and a list
     * of unsigned 64-bit ints.  Returns a list of strings.
     */
    readPackedFixed64String(): Array<string>;
    /**
     * Reads a packed sfixed32 field, which consists of a length header and a list
     * of 32-bit ints.
     */
    readPackedSfixed32(): Array<number>;
    /**
     * Reads a packed sfixed64 field, which consists of a length header and a list
     * of 64-bit ints.
     */
    readPackedSfixed64(): Array<number>;
    /**
     * Reads a packed sfixed64 field, which consists of a length header and a list
     * of 64-bit ints.  Returns a list of strings.
     */
    readPackedSfixed64String(): Array<string>;
    /**
     * Reads a packed float field, which consists of a length header and a list of
     * floats.
     */
    readPackedFloat(): Array<number>;
    /**
     * Reads a packed double field, which consists of a length header and a list of
     * doubles.
     */
    readPackedDouble(): Array<number>;
    /**
     * Reads a packed bool field, which consists of a length header and a list of
     * unsigned varints.
     */
    readPackedBool(): Array<boolean>;
    /**
     * Reads a packed enum field, which consists of a length header and a list of
     * unsigned varints.
     */
    readPackedEnum(): Array<number>;
    /**
     * Reads a packed varint hash64 field, which consists of a length header and a
     * list of varint hash64s.
     */
    readPackedVarintHash64(): Array<string>;
    /**
     * Reads a packed fixed hash64 field, which consists of a length header and a
     * list of fixed hash64s.
     */
    readPackedFixedHash64(): Array<string>;
}
