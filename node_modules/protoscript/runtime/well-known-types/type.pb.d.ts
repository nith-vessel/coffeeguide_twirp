import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { SourceContext, Any } from "protoscript";
/**
 * The syntax in which a protocol buffer element is defined.
 */
export declare type Syntax = "SYNTAX_PROTO2" | "SYNTAX_PROTO3";
/**
 * A protocol buffer message type.
 */
export interface Type {
    /**
     * The fully qualified message name.
     */
    name: string;
    /**
     * The list of fields.
     */
    fields: Field[];
    /**
     * The list of types appearing in `oneof` definitions in this type.
     */
    oneofs: string[];
    /**
     * The protocol buffer options.
     */
    options: Option[];
    /**
     * The source context.
     */
    sourceContext: SourceContext;
    /**
     * The source syntax.
     */
    syntax: Syntax;
}
/**
 * A single field of a message type.
 */
export interface Field {
    /**
     * The field type.
     */
    kind: Field.Kind;
    /**
     * The field cardinality.
     */
    cardinality: Field.Cardinality;
    /**
     * The field number.
     */
    number: number;
    /**
     * The field name.
     */
    name: string;
    /**
     * The field type URL, without the scheme, for message or enumeration
     * types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
     */
    typeUrl: string;
    /**
     * The index of the field type in `Type.oneofs`, for message or enumeration
     * types. The first type has index 1; zero means the type is not in the list.
     */
    oneofIndex: number;
    /**
     * Whether to use alternative packed wire representation.
     */
    packed: boolean;
    /**
     * The protocol buffer options.
     */
    options: Option[];
    /**
     * The field JSON name.
     */
    jsonName: string;
    /**
     * The string value of the default value of this field. Proto2 syntax only.
     */
    defaultValue: string;
}
export declare namespace Field {
    /**
     * Basic field types.
     */
    type Kind = "TYPE_UNKNOWN" | "TYPE_DOUBLE" | "TYPE_FLOAT" | "TYPE_INT64" | "TYPE_UINT64" | "TYPE_INT32" | "TYPE_FIXED64" | "TYPE_FIXED32" | "TYPE_BOOL" | "TYPE_STRING" | "TYPE_GROUP" | "TYPE_MESSAGE" | "TYPE_BYTES" | "TYPE_UINT32" | "TYPE_ENUM" | "TYPE_SFIXED32" | "TYPE_SFIXED64" | "TYPE_SINT32" | "TYPE_SINT64";
    /**
     * Whether a field is optional, required, or repeated.
     */
    type Cardinality = "CARDINALITY_UNKNOWN" | "CARDINALITY_OPTIONAL" | "CARDINALITY_REQUIRED" | "CARDINALITY_REPEATED";
}
/**
 * Enum type definition.
 */
export interface Enum {
    /**
     * Enum type name.
     */
    name: string;
    /**
     * Enum value definitions.
     */
    enumvalue: EnumValue[];
    /**
     * Protocol buffer options.
     */
    options: Option[];
    /**
     * The source context.
     */
    sourceContext: SourceContext;
    /**
     * The source syntax.
     */
    syntax: Syntax;
}
/**
 * Enum value definition.
 */
export interface EnumValue {
    /**
     * Enum value name.
     */
    name: string;
    /**
     * Enum value number.
     */
    number: number;
    /**
     * Protocol buffer options.
     */
    options: Option[];
}
/**
 * A protocol buffer option, which can be attached to a message, field,
 * enumeration, etc.
 */
export interface Option {
    /**
     * The option's name. For protobuf built-in options (options defined in
     * descriptor.proto), this is the short name. For example, `"map_entry"`.
     * For custom options, it should be the fully-qualified name. For example,
     * `"google.api.http"`.
     */
    name: string;
    /**
     * The option's value packed in an Any message. If the value is a primitive,
     * the corresponding wrapper type defined in google/protobuf/wrappers.proto
     * should be used. If the value is an enum, it should be stored as an int32
     * value using the google.protobuf.Int32Value type.
     */
    value: Any;
}
export declare const Syntax: {
    /**
     * Syntax `proto2`.
     */
    readonly SYNTAX_PROTO2: "SYNTAX_PROTO2";
    /**
     * Syntax `proto3`.
     */
    readonly SYNTAX_PROTO3: "SYNTAX_PROTO3";
    /**
     * @private
     */
    readonly _fromInt: (i: number) => Syntax;
    /**
     * @private
     */
    readonly _toInt: (i: Syntax) => number;
};
export declare const Type: {
    /**
     * Serializes Type to protobuf.
     */
    encode: (msg: Partial<Type>) => Uint8Array;
    /**
     * Deserializes Type from protobuf.
     */
    decode: (bytes: ByteSource) => Type;
    /**
     * Initializes Type with all fields set to their default value.
     */
    initialize: () => Type;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Type>, writer: BinaryWriter) => BinaryWriter;
    /**
     * @private
     */
    _readMessage: (msg: Type, reader: BinaryReader) => Type;
};
export declare const Field: {
    /**
     * Serializes Field to protobuf.
     */
    encode: (msg: Partial<Field>) => Uint8Array;
    /**
     * Deserializes Field from protobuf.
     */
    decode: (bytes: ByteSource) => Field;
    /**
     * Initializes Field with all fields set to their default value.
     */
    initialize: () => Field;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Field>, writer: BinaryWriter) => BinaryWriter;
    /**
     * @private
     */
    _readMessage: (msg: Field, reader: BinaryReader) => Field;
    Kind: {
        /**
         * Field type unknown.
         */
        readonly TYPE_UNKNOWN: "TYPE_UNKNOWN";
        /**
         * Field type double.
         */
        readonly TYPE_DOUBLE: "TYPE_DOUBLE";
        /**
         * Field type float.
         */
        readonly TYPE_FLOAT: "TYPE_FLOAT";
        /**
         * Field type int64.
         */
        readonly TYPE_INT64: "TYPE_INT64";
        /**
         * Field type uint64.
         */
        readonly TYPE_UINT64: "TYPE_UINT64";
        /**
         * Field type int32.
         */
        readonly TYPE_INT32: "TYPE_INT32";
        /**
         * Field type fixed64.
         */
        readonly TYPE_FIXED64: "TYPE_FIXED64";
        /**
         * Field type fixed32.
         */
        readonly TYPE_FIXED32: "TYPE_FIXED32";
        /**
         * Field type bool.
         */
        readonly TYPE_BOOL: "TYPE_BOOL";
        /**
         * Field type string.
         */
        readonly TYPE_STRING: "TYPE_STRING";
        /**
         * Field type group. Proto2 syntax only, and deprecated.
         */
        readonly TYPE_GROUP: "TYPE_GROUP";
        /**
         * Field type message.
         */
        readonly TYPE_MESSAGE: "TYPE_MESSAGE";
        /**
         * Field type bytes.
         */
        readonly TYPE_BYTES: "TYPE_BYTES";
        /**
         * Field type uint32.
         */
        readonly TYPE_UINT32: "TYPE_UINT32";
        /**
         * Field type enum.
         */
        readonly TYPE_ENUM: "TYPE_ENUM";
        /**
         * Field type sfixed32.
         */
        readonly TYPE_SFIXED32: "TYPE_SFIXED32";
        /**
         * Field type sfixed64.
         */
        readonly TYPE_SFIXED64: "TYPE_SFIXED64";
        /**
         * Field type sint32.
         */
        readonly TYPE_SINT32: "TYPE_SINT32";
        /**
         * Field type sint64.
         */
        readonly TYPE_SINT64: "TYPE_SINT64";
        /**
         * @private
         */
        readonly _fromInt: (i: number) => Field.Kind;
        /**
         * @private
         */
        readonly _toInt: (i: Field.Kind) => number;
    };
    Cardinality: {
        /**
         * For fields with unknown cardinality.
         */
        readonly CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN";
        /**
         * For optional fields.
         */
        readonly CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL";
        /**
         * For required fields. Proto2 syntax only.
         */
        readonly CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED";
        /**
         * For repeated fields.
         */
        readonly CARDINALITY_REPEATED: "CARDINALITY_REPEATED";
        /**
         * @private
         */
        readonly _fromInt: (i: number) => Field.Cardinality;
        /**
         * @private
         */
        readonly _toInt: (i: Field.Cardinality) => number;
    };
};
export declare const Enum: {
    /**
     * Serializes Enum to protobuf.
     */
    encode: (msg: Partial<Enum>) => Uint8Array;
    /**
     * Deserializes Enum from protobuf.
     */
    decode: (bytes: ByteSource) => Enum;
    /**
     * Initializes Enum with all fields set to their default value.
     */
    initialize: () => Enum;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Enum>, writer: BinaryWriter) => BinaryWriter;
    /**
     * @private
     */
    _readMessage: (msg: Enum, reader: BinaryReader) => Enum;
};
export declare const EnumValue: {
    /**
     * Serializes EnumValue to protobuf.
     */
    encode: (msg: Partial<EnumValue>) => Uint8Array;
    /**
     * Deserializes EnumValue from protobuf.
     */
    decode: (bytes: ByteSource) => EnumValue;
    /**
     * Initializes EnumValue with all fields set to their default value.
     */
    initialize: () => EnumValue;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<EnumValue>, writer: BinaryWriter) => BinaryWriter;
    /**
     * @private
     */
    _readMessage: (msg: EnumValue, reader: BinaryReader) => EnumValue;
};
export declare const Option: {
    /**
     * Serializes Option to protobuf.
     */
    encode: (msg: Partial<Option>) => Uint8Array;
    /**
     * Deserializes Option from protobuf.
     */
    decode: (bytes: ByteSource) => Option;
    /**
     * Initializes Option with all fields set to their default value.
     */
    initialize: () => Option;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Option>, writer: BinaryWriter) => BinaryWriter;
    /**
     * @private
     */
    _readMessage: (msg: Option, reader: BinaryReader) => Option;
};
export declare const SyntaxJSON: {
    /**
     * Syntax `proto2`.
     */
    readonly SYNTAX_PROTO2: "SYNTAX_PROTO2";
    /**
     * Syntax `proto3`.
     */
    readonly SYNTAX_PROTO3: "SYNTAX_PROTO3";
    /**
     * @private
     */
    readonly _fromInt: (i: number) => Syntax;
    /**
     * @private
     */
    readonly _toInt: (i: Syntax) => number;
};
export declare const TypeJSON: {
    /**
     * Serializes Type to JSON.
     */
    encode: (msg: Partial<Type>) => string;
    /**
     * Deserializes Type from JSON.
     */
    decode: (json: string) => Type;
    /**
     * Initializes Type with all fields set to their default value.
     */
    initialize: () => Type;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Type>) => Record<string, unknown>;
    /**
     * @private
     */
    _readMessage: (msg: Type, json: any) => Type;
};
export declare const FieldJSON: {
    /**
     * Serializes Field to JSON.
     */
    encode: (msg: Partial<Field>) => string;
    /**
     * Deserializes Field from JSON.
     */
    decode: (json: string) => Field;
    /**
     * Initializes Field with all fields set to their default value.
     */
    initialize: () => Field;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Field>) => Record<string, unknown>;
    /**
     * @private
     */
    _readMessage: (msg: Field, json: any) => Field;
    Kind: {
        /**
         * Field type unknown.
         */
        readonly TYPE_UNKNOWN: "TYPE_UNKNOWN";
        /**
         * Field type double.
         */
        readonly TYPE_DOUBLE: "TYPE_DOUBLE";
        /**
         * Field type float.
         */
        readonly TYPE_FLOAT: "TYPE_FLOAT";
        /**
         * Field type int64.
         */
        readonly TYPE_INT64: "TYPE_INT64";
        /**
         * Field type uint64.
         */
        readonly TYPE_UINT64: "TYPE_UINT64";
        /**
         * Field type int32.
         */
        readonly TYPE_INT32: "TYPE_INT32";
        /**
         * Field type fixed64.
         */
        readonly TYPE_FIXED64: "TYPE_FIXED64";
        /**
         * Field type fixed32.
         */
        readonly TYPE_FIXED32: "TYPE_FIXED32";
        /**
         * Field type bool.
         */
        readonly TYPE_BOOL: "TYPE_BOOL";
        /**
         * Field type string.
         */
        readonly TYPE_STRING: "TYPE_STRING";
        /**
         * Field type group. Proto2 syntax only, and deprecated.
         */
        readonly TYPE_GROUP: "TYPE_GROUP";
        /**
         * Field type message.
         */
        readonly TYPE_MESSAGE: "TYPE_MESSAGE";
        /**
         * Field type bytes.
         */
        readonly TYPE_BYTES: "TYPE_BYTES";
        /**
         * Field type uint32.
         */
        readonly TYPE_UINT32: "TYPE_UINT32";
        /**
         * Field type enum.
         */
        readonly TYPE_ENUM: "TYPE_ENUM";
        /**
         * Field type sfixed32.
         */
        readonly TYPE_SFIXED32: "TYPE_SFIXED32";
        /**
         * Field type sfixed64.
         */
        readonly TYPE_SFIXED64: "TYPE_SFIXED64";
        /**
         * Field type sint32.
         */
        readonly TYPE_SINT32: "TYPE_SINT32";
        /**
         * Field type sint64.
         */
        readonly TYPE_SINT64: "TYPE_SINT64";
        /**
         * @private
         */
        readonly _fromInt: (i: number) => Field.Kind;
        /**
         * @private
         */
        readonly _toInt: (i: Field.Kind) => number;
    };
    Cardinality: {
        /**
         * For fields with unknown cardinality.
         */
        readonly CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN";
        /**
         * For optional fields.
         */
        readonly CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL";
        /**
         * For required fields. Proto2 syntax only.
         */
        readonly CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED";
        /**
         * For repeated fields.
         */
        readonly CARDINALITY_REPEATED: "CARDINALITY_REPEATED";
        /**
         * @private
         */
        readonly _fromInt: (i: number) => Field.Cardinality;
        /**
         * @private
         */
        readonly _toInt: (i: Field.Cardinality) => number;
    };
};
export declare const EnumJSON: {
    /**
     * Serializes Enum to JSON.
     */
    encode: (msg: Partial<Enum>) => string;
    /**
     * Deserializes Enum from JSON.
     */
    decode: (json: string) => Enum;
    /**
     * Initializes Enum with all fields set to their default value.
     */
    initialize: () => Enum;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Enum>) => Record<string, unknown>;
    /**
     * @private
     */
    _readMessage: (msg: Enum, json: any) => Enum;
};
export declare const EnumValueJSON: {
    /**
     * Serializes EnumValue to JSON.
     */
    encode: (msg: Partial<EnumValue>) => string;
    /**
     * Deserializes EnumValue from JSON.
     */
    decode: (json: string) => EnumValue;
    /**
     * Initializes EnumValue with all fields set to their default value.
     */
    initialize: () => EnumValue;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<EnumValue>) => Record<string, unknown>;
    /**
     * @private
     */
    _readMessage: (msg: EnumValue, json: any) => EnumValue;
};
export declare const OptionJSON: {
    /**
     * Serializes Option to JSON.
     */
    encode: (msg: Partial<Option>) => string;
    /**
     * Deserializes Option from JSON.
     */
    decode: (json: string) => Option;
    /**
     * Initializes Option with all fields set to their default value.
     */
    initialize: () => Option;
    /**
     * @private
     */
    _writeMessage: (msg: Partial<Option>) => Record<string, unknown>;
    /**
     * @private
     */
    _readMessage: (msg: Option, json: any) => Option;
};
