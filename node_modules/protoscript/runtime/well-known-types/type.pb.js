// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "protoscript";
import { SourceContext, SourceContextJSON, Any, AnyJSON } from "protoscript";
//========================================//
//        Protobuf Encode / Decode        //
//========================================//
export const Syntax = {
    /**
     * Syntax `proto2`.
     */
    SYNTAX_PROTO2: "SYNTAX_PROTO2",
    /**
     * Syntax `proto3`.
     */
    SYNTAX_PROTO3: "SYNTAX_PROTO3",
    /**
     * @private
     */
    _fromInt: function (i) {
        switch (i) {
            case 0: {
                return "SYNTAX_PROTO2";
            }
            case 1: {
                return "SYNTAX_PROTO3";
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
    /**
     * @private
     */
    _toInt: function (i) {
        switch (i) {
            case "SYNTAX_PROTO2": {
                return 0;
            }
            case "SYNTAX_PROTO3": {
                return 1;
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
};
export const Type = {
    /**
     * Serializes Type to protobuf.
     */
    encode: function (msg) {
        return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Type from protobuf.
     */
    decode: function (bytes) {
        return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Type with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            fields: [],
            oneofs: [],
            options: [],
            sourceContext: SourceContext.initialize(),
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.fields?.length) {
            writer.writeRepeatedMessage(2, msg.fields, Field._writeMessage);
        }
        if (msg.oneofs?.length) {
            writer.writeRepeatedString(3, msg.oneofs);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(4, msg.options, Option._writeMessage);
        }
        if (msg.sourceContext) {
            writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
        }
        if (msg.syntax && Syntax._toInt(msg.syntax)) {
            writer.writeEnum(6, Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    const m = Field.initialize();
                    reader.readMessage(m, Field._readMessage);
                    msg.fields.push(m);
                    break;
                }
                case 3: {
                    msg.oneofs.push(reader.readString());
                    break;
                }
                case 4: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 5: {
                    reader.readMessage(msg.sourceContext, SourceContext._readMessage);
                    break;
                }
                case 6: {
                    msg.syntax = Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Field = {
    /**
     * Serializes Field to protobuf.
     */
    encode: function (msg) {
        return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Field from protobuf.
     */
    decode: function (bytes) {
        return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Field with all fields set to their default value.
     */
    initialize: function () {
        return {
            kind: Field.Kind._fromInt(0),
            cardinality: Field.Cardinality._fromInt(0),
            number: 0,
            name: "",
            typeUrl: "",
            oneofIndex: 0,
            packed: false,
            options: [],
            jsonName: "",
            defaultValue: "",
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.kind && Field.Kind._toInt(msg.kind)) {
            writer.writeEnum(1, Field.Kind._toInt(msg.kind));
        }
        if (msg.cardinality && Field.Cardinality._toInt(msg.cardinality)) {
            writer.writeEnum(2, Field.Cardinality._toInt(msg.cardinality));
        }
        if (msg.number) {
            writer.writeInt32(3, msg.number);
        }
        if (msg.name) {
            writer.writeString(4, msg.name);
        }
        if (msg.typeUrl) {
            writer.writeString(6, msg.typeUrl);
        }
        if (msg.oneofIndex) {
            writer.writeInt32(7, msg.oneofIndex);
        }
        if (msg.packed) {
            writer.writeBool(8, msg.packed);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(9, msg.options, Option._writeMessage);
        }
        if (msg.jsonName) {
            writer.writeString(10, msg.jsonName);
        }
        if (msg.defaultValue) {
            writer.writeString(11, msg.defaultValue);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.kind = Field.Kind._fromInt(reader.readEnum());
                    break;
                }
                case 2: {
                    msg.cardinality = Field.Cardinality._fromInt(reader.readEnum());
                    break;
                }
                case 3: {
                    msg.number = reader.readInt32();
                    break;
                }
                case 4: {
                    msg.name = reader.readString();
                    break;
                }
                case 6: {
                    msg.typeUrl = reader.readString();
                    break;
                }
                case 7: {
                    msg.oneofIndex = reader.readInt32();
                    break;
                }
                case 8: {
                    msg.packed = reader.readBool();
                    break;
                }
                case 9: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 10: {
                    msg.jsonName = reader.readString();
                    break;
                }
                case 11: {
                    msg.defaultValue = reader.readString();
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
    Kind: {
        /**
         * Field type unknown.
         */
        TYPE_UNKNOWN: "TYPE_UNKNOWN",
        /**
         * Field type double.
         */
        TYPE_DOUBLE: "TYPE_DOUBLE",
        /**
         * Field type float.
         */
        TYPE_FLOAT: "TYPE_FLOAT",
        /**
         * Field type int64.
         */
        TYPE_INT64: "TYPE_INT64",
        /**
         * Field type uint64.
         */
        TYPE_UINT64: "TYPE_UINT64",
        /**
         * Field type int32.
         */
        TYPE_INT32: "TYPE_INT32",
        /**
         * Field type fixed64.
         */
        TYPE_FIXED64: "TYPE_FIXED64",
        /**
         * Field type fixed32.
         */
        TYPE_FIXED32: "TYPE_FIXED32",
        /**
         * Field type bool.
         */
        TYPE_BOOL: "TYPE_BOOL",
        /**
         * Field type string.
         */
        TYPE_STRING: "TYPE_STRING",
        /**
         * Field type group. Proto2 syntax only, and deprecated.
         */
        TYPE_GROUP: "TYPE_GROUP",
        /**
         * Field type message.
         */
        TYPE_MESSAGE: "TYPE_MESSAGE",
        /**
         * Field type bytes.
         */
        TYPE_BYTES: "TYPE_BYTES",
        /**
         * Field type uint32.
         */
        TYPE_UINT32: "TYPE_UINT32",
        /**
         * Field type enum.
         */
        TYPE_ENUM: "TYPE_ENUM",
        /**
         * Field type sfixed32.
         */
        TYPE_SFIXED32: "TYPE_SFIXED32",
        /**
         * Field type sfixed64.
         */
        TYPE_SFIXED64: "TYPE_SFIXED64",
        /**
         * Field type sint32.
         */
        TYPE_SINT32: "TYPE_SINT32",
        /**
         * Field type sint64.
         */
        TYPE_SINT64: "TYPE_SINT64",
        /**
         * @private
         */
        _fromInt: function (i) {
            switch (i) {
                case 0: {
                    return "TYPE_UNKNOWN";
                }
                case 1: {
                    return "TYPE_DOUBLE";
                }
                case 2: {
                    return "TYPE_FLOAT";
                }
                case 3: {
                    return "TYPE_INT64";
                }
                case 4: {
                    return "TYPE_UINT64";
                }
                case 5: {
                    return "TYPE_INT32";
                }
                case 6: {
                    return "TYPE_FIXED64";
                }
                case 7: {
                    return "TYPE_FIXED32";
                }
                case 8: {
                    return "TYPE_BOOL";
                }
                case 9: {
                    return "TYPE_STRING";
                }
                case 10: {
                    return "TYPE_GROUP";
                }
                case 11: {
                    return "TYPE_MESSAGE";
                }
                case 12: {
                    return "TYPE_BYTES";
                }
                case 13: {
                    return "TYPE_UINT32";
                }
                case 14: {
                    return "TYPE_ENUM";
                }
                case 15: {
                    return "TYPE_SFIXED32";
                }
                case 16: {
                    return "TYPE_SFIXED64";
                }
                case 17: {
                    return "TYPE_SINT32";
                }
                case 18: {
                    return "TYPE_SINT64";
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
        /**
         * @private
         */
        _toInt: function (i) {
            switch (i) {
                case "TYPE_UNKNOWN": {
                    return 0;
                }
                case "TYPE_DOUBLE": {
                    return 1;
                }
                case "TYPE_FLOAT": {
                    return 2;
                }
                case "TYPE_INT64": {
                    return 3;
                }
                case "TYPE_UINT64": {
                    return 4;
                }
                case "TYPE_INT32": {
                    return 5;
                }
                case "TYPE_FIXED64": {
                    return 6;
                }
                case "TYPE_FIXED32": {
                    return 7;
                }
                case "TYPE_BOOL": {
                    return 8;
                }
                case "TYPE_STRING": {
                    return 9;
                }
                case "TYPE_GROUP": {
                    return 10;
                }
                case "TYPE_MESSAGE": {
                    return 11;
                }
                case "TYPE_BYTES": {
                    return 12;
                }
                case "TYPE_UINT32": {
                    return 13;
                }
                case "TYPE_ENUM": {
                    return 14;
                }
                case "TYPE_SFIXED32": {
                    return 15;
                }
                case "TYPE_SFIXED64": {
                    return 16;
                }
                case "TYPE_SINT32": {
                    return 17;
                }
                case "TYPE_SINT64": {
                    return 18;
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
    },
    Cardinality: {
        /**
         * For fields with unknown cardinality.
         */
        CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
        /**
         * For optional fields.
         */
        CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
        /**
         * For required fields. Proto2 syntax only.
         */
        CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
        /**
         * For repeated fields.
         */
        CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
        /**
         * @private
         */
        _fromInt: function (i) {
            switch (i) {
                case 0: {
                    return "CARDINALITY_UNKNOWN";
                }
                case 1: {
                    return "CARDINALITY_OPTIONAL";
                }
                case 2: {
                    return "CARDINALITY_REQUIRED";
                }
                case 3: {
                    return "CARDINALITY_REPEATED";
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
        /**
         * @private
         */
        _toInt: function (i) {
            switch (i) {
                case "CARDINALITY_UNKNOWN": {
                    return 0;
                }
                case "CARDINALITY_OPTIONAL": {
                    return 1;
                }
                case "CARDINALITY_REQUIRED": {
                    return 2;
                }
                case "CARDINALITY_REPEATED": {
                    return 3;
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
    },
};
export const Enum = {
    /**
     * Serializes Enum to protobuf.
     */
    encode: function (msg) {
        return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Enum from protobuf.
     */
    decode: function (bytes) {
        return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Enum with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            enumvalue: [],
            options: [],
            sourceContext: SourceContext.initialize(),
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.enumvalue?.length) {
            writer.writeRepeatedMessage(2, msg.enumvalue, EnumValue._writeMessage);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
        }
        if (msg.sourceContext) {
            writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
        }
        if (msg.syntax && Syntax._toInt(msg.syntax)) {
            writer.writeEnum(5, Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    const m = EnumValue.initialize();
                    reader.readMessage(m, EnumValue._readMessage);
                    msg.enumvalue.push(m);
                    break;
                }
                case 3: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 4: {
                    reader.readMessage(msg.sourceContext, SourceContext._readMessage);
                    break;
                }
                case 5: {
                    msg.syntax = Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const EnumValue = {
    /**
     * Serializes EnumValue to protobuf.
     */
    encode: function (msg) {
        return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes EnumValue from protobuf.
     */
    decode: function (bytes) {
        return EnumValue._readMessage(EnumValue.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes EnumValue with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            number: 0,
            options: [],
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.number) {
            writer.writeInt32(2, msg.number);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    msg.number = reader.readInt32();
                    break;
                }
                case 3: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Option = {
    /**
     * Serializes Option to protobuf.
     */
    encode: function (msg) {
        return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Option from protobuf.
     */
    decode: function (bytes) {
        return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Option with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            value: Any.initialize(),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.value) {
            writer.writeMessage(2, msg.value, Any._writeMessage);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    reader.readMessage(msg.value, Any._readMessage);
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
//========================================//
//          JSON Encode / Decode          //
//========================================//
export const SyntaxJSON = {
    /**
     * Syntax `proto2`.
     */
    SYNTAX_PROTO2: "SYNTAX_PROTO2",
    /**
     * Syntax `proto3`.
     */
    SYNTAX_PROTO3: "SYNTAX_PROTO3",
    /**
     * @private
     */
    _fromInt: function (i) {
        switch (i) {
            case 0: {
                return "SYNTAX_PROTO2";
            }
            case 1: {
                return "SYNTAX_PROTO3";
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
    /**
     * @private
     */
    _toInt: function (i) {
        switch (i) {
            case "SYNTAX_PROTO2": {
                return 0;
            }
            case "SYNTAX_PROTO3": {
                return 1;
            }
            // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
            default: {
                return i;
            }
        }
    },
};
export const TypeJSON = {
    /**
     * Serializes Type to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(TypeJSON._writeMessage(msg));
    },
    /**
     * Deserializes Type from JSON.
     */
    decode: function (json) {
        return TypeJSON._readMessage(TypeJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Type with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            fields: [],
            oneofs: [],
            options: [],
            sourceContext: SourceContext.initialize(),
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.fields?.length) {
            json["fields"] = msg.fields.map(FieldJSON._writeMessage);
        }
        if (msg.oneofs?.length) {
            json["oneofs"] = msg.oneofs;
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        if (msg.sourceContext) {
            const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
            if (Object.keys(sourceContext).length > 0) {
                json["sourceContext"] = sourceContext;
            }
        }
        if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _fields = json["fields"];
        if (_fields) {
            for (const item of _fields) {
                const m = Field.initialize();
                FieldJSON._readMessage(m, item);
                msg.fields.push(m);
            }
        }
        const _oneofs = json["oneofs"];
        if (_oneofs) {
            msg.oneofs = _oneofs;
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _sourceContext = json["sourceContext"] ?? json["source_context"];
        if (_sourceContext) {
            const m = SourceContext.initialize();
            SourceContextJSON._readMessage(m, _sourceContext);
            msg.sourceContext = m;
        }
        const _syntax = json["syntax"];
        if (_syntax) {
            msg.syntax = _syntax;
        }
        return msg;
    },
};
export const FieldJSON = {
    /**
     * Serializes Field to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(FieldJSON._writeMessage(msg));
    },
    /**
     * Deserializes Field from JSON.
     */
    decode: function (json) {
        return FieldJSON._readMessage(FieldJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Field with all fields set to their default value.
     */
    initialize: function () {
        return {
            kind: Field.Kind._fromInt(0),
            cardinality: Field.Cardinality._fromInt(0),
            number: 0,
            name: "",
            typeUrl: "",
            oneofIndex: 0,
            packed: false,
            options: [],
            jsonName: "",
            defaultValue: "",
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.kind && FieldJSON.Kind._toInt(msg.kind)) {
            json["kind"] = msg.kind;
        }
        if (msg.cardinality && FieldJSON.Cardinality._toInt(msg.cardinality)) {
            json["cardinality"] = msg.cardinality;
        }
        if (msg.number) {
            json["number"] = msg.number;
        }
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.typeUrl) {
            json["typeUrl"] = msg.typeUrl;
        }
        if (msg.oneofIndex) {
            json["oneofIndex"] = msg.oneofIndex;
        }
        if (msg.packed) {
            json["packed"] = msg.packed;
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        if (msg.jsonName) {
            json["jsonName"] = msg.jsonName;
        }
        if (msg.defaultValue) {
            json["defaultValue"] = msg.defaultValue;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _kind = json["kind"];
        if (_kind) {
            msg.kind = _kind;
        }
        const _cardinality = json["cardinality"];
        if (_cardinality) {
            msg.cardinality = _cardinality;
        }
        const _number = json["number"];
        if (_number) {
            msg.number = _number;
        }
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _typeUrl = json["typeUrl"] ?? json["type_url"];
        if (_typeUrl) {
            msg.typeUrl = _typeUrl;
        }
        const _oneofIndex = json["oneofIndex"] ?? json["oneof_index"];
        if (_oneofIndex) {
            msg.oneofIndex = _oneofIndex;
        }
        const _packed = json["packed"];
        if (_packed) {
            msg.packed = _packed;
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _jsonName = json["jsonName"] ?? json["json_name"];
        if (_jsonName) {
            msg.jsonName = _jsonName;
        }
        const _defaultValue = json["defaultValue"] ?? json["default_value"];
        if (_defaultValue) {
            msg.defaultValue = _defaultValue;
        }
        return msg;
    },
    Kind: {
        /**
         * Field type unknown.
         */
        TYPE_UNKNOWN: "TYPE_UNKNOWN",
        /**
         * Field type double.
         */
        TYPE_DOUBLE: "TYPE_DOUBLE",
        /**
         * Field type float.
         */
        TYPE_FLOAT: "TYPE_FLOAT",
        /**
         * Field type int64.
         */
        TYPE_INT64: "TYPE_INT64",
        /**
         * Field type uint64.
         */
        TYPE_UINT64: "TYPE_UINT64",
        /**
         * Field type int32.
         */
        TYPE_INT32: "TYPE_INT32",
        /**
         * Field type fixed64.
         */
        TYPE_FIXED64: "TYPE_FIXED64",
        /**
         * Field type fixed32.
         */
        TYPE_FIXED32: "TYPE_FIXED32",
        /**
         * Field type bool.
         */
        TYPE_BOOL: "TYPE_BOOL",
        /**
         * Field type string.
         */
        TYPE_STRING: "TYPE_STRING",
        /**
         * Field type group. Proto2 syntax only, and deprecated.
         */
        TYPE_GROUP: "TYPE_GROUP",
        /**
         * Field type message.
         */
        TYPE_MESSAGE: "TYPE_MESSAGE",
        /**
         * Field type bytes.
         */
        TYPE_BYTES: "TYPE_BYTES",
        /**
         * Field type uint32.
         */
        TYPE_UINT32: "TYPE_UINT32",
        /**
         * Field type enum.
         */
        TYPE_ENUM: "TYPE_ENUM",
        /**
         * Field type sfixed32.
         */
        TYPE_SFIXED32: "TYPE_SFIXED32",
        /**
         * Field type sfixed64.
         */
        TYPE_SFIXED64: "TYPE_SFIXED64",
        /**
         * Field type sint32.
         */
        TYPE_SINT32: "TYPE_SINT32",
        /**
         * Field type sint64.
         */
        TYPE_SINT64: "TYPE_SINT64",
        /**
         * @private
         */
        _fromInt: function (i) {
            switch (i) {
                case 0: {
                    return "TYPE_UNKNOWN";
                }
                case 1: {
                    return "TYPE_DOUBLE";
                }
                case 2: {
                    return "TYPE_FLOAT";
                }
                case 3: {
                    return "TYPE_INT64";
                }
                case 4: {
                    return "TYPE_UINT64";
                }
                case 5: {
                    return "TYPE_INT32";
                }
                case 6: {
                    return "TYPE_FIXED64";
                }
                case 7: {
                    return "TYPE_FIXED32";
                }
                case 8: {
                    return "TYPE_BOOL";
                }
                case 9: {
                    return "TYPE_STRING";
                }
                case 10: {
                    return "TYPE_GROUP";
                }
                case 11: {
                    return "TYPE_MESSAGE";
                }
                case 12: {
                    return "TYPE_BYTES";
                }
                case 13: {
                    return "TYPE_UINT32";
                }
                case 14: {
                    return "TYPE_ENUM";
                }
                case 15: {
                    return "TYPE_SFIXED32";
                }
                case 16: {
                    return "TYPE_SFIXED64";
                }
                case 17: {
                    return "TYPE_SINT32";
                }
                case 18: {
                    return "TYPE_SINT64";
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
        /**
         * @private
         */
        _toInt: function (i) {
            switch (i) {
                case "TYPE_UNKNOWN": {
                    return 0;
                }
                case "TYPE_DOUBLE": {
                    return 1;
                }
                case "TYPE_FLOAT": {
                    return 2;
                }
                case "TYPE_INT64": {
                    return 3;
                }
                case "TYPE_UINT64": {
                    return 4;
                }
                case "TYPE_INT32": {
                    return 5;
                }
                case "TYPE_FIXED64": {
                    return 6;
                }
                case "TYPE_FIXED32": {
                    return 7;
                }
                case "TYPE_BOOL": {
                    return 8;
                }
                case "TYPE_STRING": {
                    return 9;
                }
                case "TYPE_GROUP": {
                    return 10;
                }
                case "TYPE_MESSAGE": {
                    return 11;
                }
                case "TYPE_BYTES": {
                    return 12;
                }
                case "TYPE_UINT32": {
                    return 13;
                }
                case "TYPE_ENUM": {
                    return 14;
                }
                case "TYPE_SFIXED32": {
                    return 15;
                }
                case "TYPE_SFIXED64": {
                    return 16;
                }
                case "TYPE_SINT32": {
                    return 17;
                }
                case "TYPE_SINT64": {
                    return 18;
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
    },
    Cardinality: {
        /**
         * For fields with unknown cardinality.
         */
        CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
        /**
         * For optional fields.
         */
        CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
        /**
         * For required fields. Proto2 syntax only.
         */
        CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
        /**
         * For repeated fields.
         */
        CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
        /**
         * @private
         */
        _fromInt: function (i) {
            switch (i) {
                case 0: {
                    return "CARDINALITY_UNKNOWN";
                }
                case 1: {
                    return "CARDINALITY_OPTIONAL";
                }
                case 2: {
                    return "CARDINALITY_REQUIRED";
                }
                case 3: {
                    return "CARDINALITY_REPEATED";
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
        /**
         * @private
         */
        _toInt: function (i) {
            switch (i) {
                case "CARDINALITY_UNKNOWN": {
                    return 0;
                }
                case "CARDINALITY_OPTIONAL": {
                    return 1;
                }
                case "CARDINALITY_REQUIRED": {
                    return 2;
                }
                case "CARDINALITY_REPEATED": {
                    return 3;
                }
                // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
                default: {
                    return i;
                }
            }
        },
    },
};
export const EnumJSON = {
    /**
     * Serializes Enum to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(EnumJSON._writeMessage(msg));
    },
    /**
     * Deserializes Enum from JSON.
     */
    decode: function (json) {
        return EnumJSON._readMessage(EnumJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Enum with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            enumvalue: [],
            options: [],
            sourceContext: SourceContext.initialize(),
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.enumvalue?.length) {
            json["enumvalue"] = msg.enumvalue.map(EnumValueJSON._writeMessage);
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        if (msg.sourceContext) {
            const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
            if (Object.keys(sourceContext).length > 0) {
                json["sourceContext"] = sourceContext;
            }
        }
        if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _enumvalue = json["enumvalue"];
        if (_enumvalue) {
            for (const item of _enumvalue) {
                const m = EnumValue.initialize();
                EnumValueJSON._readMessage(m, item);
                msg.enumvalue.push(m);
            }
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _sourceContext = json["sourceContext"] ?? json["source_context"];
        if (_sourceContext) {
            const m = SourceContext.initialize();
            SourceContextJSON._readMessage(m, _sourceContext);
            msg.sourceContext = m;
        }
        const _syntax = json["syntax"];
        if (_syntax) {
            msg.syntax = _syntax;
        }
        return msg;
    },
};
export const EnumValueJSON = {
    /**
     * Serializes EnumValue to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(EnumValueJSON._writeMessage(msg));
    },
    /**
     * Deserializes EnumValue from JSON.
     */
    decode: function (json) {
        return EnumValueJSON._readMessage(EnumValueJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes EnumValue with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            number: 0,
            options: [],
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.number) {
            json["number"] = msg.number;
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _number = json["number"];
        if (_number) {
            msg.number = _number;
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        return msg;
    },
};
export const OptionJSON = {
    /**
     * Serializes Option to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(OptionJSON._writeMessage(msg));
    },
    /**
     * Deserializes Option from JSON.
     */
    decode: function (json) {
        return OptionJSON._readMessage(OptionJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Option with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            value: Any.initialize(),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.value) {
            const value = AnyJSON._writeMessage(msg.value);
            if (Object.keys(value).length > 0) {
                json["value"] = value;
            }
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _value = json["value"];
        if (_value) {
            const m = Any.initialize();
            AnyJSON._readMessage(m, _value);
            msg.value = m;
        }
        return msg;
    },
};
