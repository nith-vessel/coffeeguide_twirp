// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "protoscript";
import { Option, OptionJSON, SourceContext, SourceContextJSON, Syntax, SyntaxJSON, } from "protoscript";
//========================================//
//        Protobuf Encode / Decode        //
//========================================//
export const Api = {
    /**
     * Serializes Api to protobuf.
     */
    encode: function (msg) {
        return Api._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Api from protobuf.
     */
    decode: function (bytes) {
        return Api._readMessage(Api.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Api with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            methods: [],
            options: [],
            version: "",
            sourceContext: SourceContext.initialize(),
            mixins: [],
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.methods?.length) {
            writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
        }
        if (msg.version) {
            writer.writeString(4, msg.version);
        }
        if (msg.sourceContext) {
            writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
        }
        if (msg.mixins?.length) {
            writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
        }
        if (msg.syntax && Syntax._toInt(msg.syntax)) {
            writer.writeEnum(7, Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    const m = Method.initialize();
                    reader.readMessage(m, Method._readMessage);
                    msg.methods.push(m);
                    break;
                }
                case 3: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 4: {
                    msg.version = reader.readString();
                    break;
                }
                case 5: {
                    reader.readMessage(msg.sourceContext, SourceContext._readMessage);
                    break;
                }
                case 6: {
                    const m = Mixin.initialize();
                    reader.readMessage(m, Mixin._readMessage);
                    msg.mixins.push(m);
                    break;
                }
                case 7: {
                    msg.syntax = Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Method = {
    /**
     * Serializes Method to protobuf.
     */
    encode: function (msg) {
        return Method._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Method from protobuf.
     */
    decode: function (bytes) {
        return Method._readMessage(Method.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Method with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            requestTypeUrl: "",
            requestStreaming: false,
            responseTypeUrl: "",
            responseStreaming: false,
            options: [],
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.requestTypeUrl) {
            writer.writeString(2, msg.requestTypeUrl);
        }
        if (msg.requestStreaming) {
            writer.writeBool(3, msg.requestStreaming);
        }
        if (msg.responseTypeUrl) {
            writer.writeString(4, msg.responseTypeUrl);
        }
        if (msg.responseStreaming) {
            writer.writeBool(5, msg.responseStreaming);
        }
        if (msg.options?.length) {
            writer.writeRepeatedMessage(6, msg.options, Option._writeMessage);
        }
        if (msg.syntax && Syntax._toInt(msg.syntax)) {
            writer.writeEnum(7, Syntax._toInt(msg.syntax));
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    msg.requestTypeUrl = reader.readString();
                    break;
                }
                case 3: {
                    msg.requestStreaming = reader.readBool();
                    break;
                }
                case 4: {
                    msg.responseTypeUrl = reader.readString();
                    break;
                }
                case 5: {
                    msg.responseStreaming = reader.readBool();
                    break;
                }
                case 6: {
                    const m = Option.initialize();
                    reader.readMessage(m, Option._readMessage);
                    msg.options.push(m);
                    break;
                }
                case 7: {
                    msg.syntax = Syntax._fromInt(reader.readEnum());
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
export const Mixin = {
    /**
     * Serializes Mixin to protobuf.
     */
    encode: function (msg) {
        return Mixin._writeMessage(msg, new BinaryWriter()).getResultBuffer();
    },
    /**
     * Deserializes Mixin from protobuf.
     */
    decode: function (bytes) {
        return Mixin._readMessage(Mixin.initialize(), new BinaryReader(bytes));
    },
    /**
     * Initializes Mixin with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            root: "",
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
        if (msg.name) {
            writer.writeString(1, msg.name);
        }
        if (msg.root) {
            writer.writeString(2, msg.root);
        }
        return writer;
    },
    /**
     * @private
     */
    _readMessage: function (msg, reader) {
        while (reader.nextField()) {
            const field = reader.getFieldNumber();
            switch (field) {
                case 1: {
                    msg.name = reader.readString();
                    break;
                }
                case 2: {
                    msg.root = reader.readString();
                    break;
                }
                default: {
                    reader.skipField();
                    break;
                }
            }
        }
        return msg;
    },
};
//========================================//
//          JSON Encode / Decode          //
//========================================//
export const ApiJSON = {
    /**
     * Serializes Api to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(ApiJSON._writeMessage(msg));
    },
    /**
     * Deserializes Api from JSON.
     */
    decode: function (json) {
        return ApiJSON._readMessage(ApiJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Api with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            methods: [],
            options: [],
            version: "",
            sourceContext: SourceContext.initialize(),
            mixins: [],
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.methods?.length) {
            json["methods"] = msg.methods.map(MethodJSON._writeMessage);
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        if (msg.version) {
            json["version"] = msg.version;
        }
        if (msg.sourceContext) {
            const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
            if (Object.keys(sourceContext).length > 0) {
                json["sourceContext"] = sourceContext;
            }
        }
        if (msg.mixins?.length) {
            json["mixins"] = msg.mixins.map(MixinJSON._writeMessage);
        }
        if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _methods = json["methods"];
        if (_methods) {
            for (const item of _methods) {
                const m = Method.initialize();
                MethodJSON._readMessage(m, item);
                msg.methods.push(m);
            }
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _version = json["version"];
        if (_version) {
            msg.version = _version;
        }
        const _sourceContext = json["sourceContext"] ?? json["source_context"];
        if (_sourceContext) {
            const m = SourceContext.initialize();
            SourceContextJSON._readMessage(m, _sourceContext);
            msg.sourceContext = m;
        }
        const _mixins = json["mixins"];
        if (_mixins) {
            for (const item of _mixins) {
                const m = Mixin.initialize();
                MixinJSON._readMessage(m, item);
                msg.mixins.push(m);
            }
        }
        const _syntax = json["syntax"];
        if (_syntax) {
            msg.syntax = _syntax;
        }
        return msg;
    },
};
export const MethodJSON = {
    /**
     * Serializes Method to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(MethodJSON._writeMessage(msg));
    },
    /**
     * Deserializes Method from JSON.
     */
    decode: function (json) {
        return MethodJSON._readMessage(MethodJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Method with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            requestTypeUrl: "",
            requestStreaming: false,
            responseTypeUrl: "",
            responseStreaming: false,
            options: [],
            syntax: Syntax._fromInt(0),
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.requestTypeUrl) {
            json["requestTypeUrl"] = msg.requestTypeUrl;
        }
        if (msg.requestStreaming) {
            json["requestStreaming"] = msg.requestStreaming;
        }
        if (msg.responseTypeUrl) {
            json["responseTypeUrl"] = msg.responseTypeUrl;
        }
        if (msg.responseStreaming) {
            json["responseStreaming"] = msg.responseStreaming;
        }
        if (msg.options?.length) {
            json["options"] = msg.options.map(OptionJSON._writeMessage);
        }
        if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
            json["syntax"] = msg.syntax;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _requestTypeUrl = json["requestTypeUrl"] ?? json["request_type_url"];
        if (_requestTypeUrl) {
            msg.requestTypeUrl = _requestTypeUrl;
        }
        const _requestStreaming = json["requestStreaming"] ?? json["request_streaming"];
        if (_requestStreaming) {
            msg.requestStreaming = _requestStreaming;
        }
        const _responseTypeUrl = json["responseTypeUrl"] ?? json["response_type_url"];
        if (_responseTypeUrl) {
            msg.responseTypeUrl = _responseTypeUrl;
        }
        const _responseStreaming = json["responseStreaming"] ?? json["response_streaming"];
        if (_responseStreaming) {
            msg.responseStreaming = _responseStreaming;
        }
        const _options = json["options"];
        if (_options) {
            for (const item of _options) {
                const m = Option.initialize();
                OptionJSON._readMessage(m, item);
                msg.options.push(m);
            }
        }
        const _syntax = json["syntax"];
        if (_syntax) {
            msg.syntax = _syntax;
        }
        return msg;
    },
};
export const MixinJSON = {
    /**
     * Serializes Mixin to JSON.
     */
    encode: function (msg) {
        return JSON.stringify(MixinJSON._writeMessage(msg));
    },
    /**
     * Deserializes Mixin from JSON.
     */
    decode: function (json) {
        return MixinJSON._readMessage(MixinJSON.initialize(), JSON.parse(json));
    },
    /**
     * Initializes Mixin with all fields set to their default value.
     */
    initialize: function () {
        return {
            name: "",
            root: "",
        };
    },
    /**
     * @private
     */
    _writeMessage: function (msg) {
        const json = {};
        if (msg.name) {
            json["name"] = msg.name;
        }
        if (msg.root) {
            json["root"] = msg.root;
        }
        return json;
    },
    /**
     * @private
     */
    _readMessage: function (msg, json) {
        const _name = json["name"];
        if (_name) {
            msg.name = _name;
        }
        const _root = json["root"];
        if (_root) {
            msg.root = _root;
        }
        return msg;
    },
};
