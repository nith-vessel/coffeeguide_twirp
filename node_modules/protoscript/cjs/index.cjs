"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Any: () => Any2,
  AnyJSON: () => AnyJSON2,
  Api: () => Api,
  ApiJSON: () => ApiJSON,
  BinaryReader: () => BinaryReader,
  BinaryWriter: () => BinaryWriter,
  BoolValue: () => BoolValue,
  BoolValueJSON: () => BoolValueJSON,
  BytesValue: () => BytesValue,
  BytesValueJSON: () => BytesValueJSON,
  DoubleValue: () => DoubleValue,
  DoubleValueJSON: () => DoubleValueJSON,
  Duration: () => Duration,
  DurationJSON: () => DurationJSON,
  Empty: () => Empty,
  EmptyJSON: () => EmptyJSON,
  Enum: () => Enum,
  EnumJSON: () => EnumJSON,
  EnumValue: () => EnumValue,
  EnumValueJSON: () => EnumValueJSON,
  Field: () => Field,
  FieldJSON: () => FieldJSON,
  FieldMask: () => FieldMask,
  FieldMaskJSON: () => FieldMaskJSON,
  FloatValue: () => FloatValue,
  FloatValueJSON: () => FloatValueJSON,
  Int32Value: () => Int32Value,
  Int32ValueJSON: () => Int32ValueJSON,
  Int64Value: () => Int64Value,
  Int64ValueJSON: () => Int64ValueJSON,
  ListValue: () => ListValue,
  ListValueJSON: () => ListValueJSON,
  Method: () => Method,
  MethodJSON: () => MethodJSON,
  Mixin: () => Mixin,
  MixinJSON: () => MixinJSON,
  NullValue: () => NullValue,
  NullValueJSON: () => NullValueJSON,
  Option: () => Option2,
  OptionJSON: () => OptionJSON2,
  SourceContext: () => SourceContext2,
  SourceContextJSON: () => SourceContextJSON2,
  StringValue: () => StringValue,
  StringValueJSON: () => StringValueJSON,
  Struct: () => Struct,
  StructJSON: () => StructJSON,
  Syntax: () => Syntax2,
  SyntaxJSON: () => SyntaxJSON2,
  Timestamp: () => Timestamp,
  TimestampJSON: () => TimestampJSON,
  Type: () => Type,
  TypeJSON: () => TypeJSON,
  UInt32Value: () => UInt32Value,
  UInt32ValueJSON: () => UInt32ValueJSON,
  UInt64Value: () => UInt64Value,
  UInt64ValueJSON: () => UInt64ValueJSON,
  Value: () => Value,
  ValueJSON: () => ValueJSON,
  decodeBase64Bytes: () => decodeBase64Bytes,
  encodeBase64Bytes: () => encodeBase64Bytes
});
module.exports = __toCommonJS(src_exports);

// src/runtime/goog/asserts.ts
var assert = (condition) => {
  if (!condition) {
    throw new Error("Assertion failed");
  }
  return condition;
};
var fail = (message) => {
  throw new Error(message);
};

// src/runtime/constants.ts
var FieldType = {
  INVALID: -1,
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18,
  FHASH64: 30,
  VHASH64: 31
};
var WireType = {
  INVALID: -1,
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};
var FieldTypeToWireType = function(fieldType) {
  switch (fieldType) {
    case FieldType.INT32:
    case FieldType.INT64:
    case FieldType.UINT32:
    case FieldType.UINT64:
    case FieldType.SINT32:
    case FieldType.SINT64:
    case FieldType.BOOL:
    case FieldType.ENUM:
    case FieldType.VHASH64:
      return WireType.VARINT;
    case FieldType.DOUBLE:
    case FieldType.FIXED64:
    case FieldType.SFIXED64:
    case FieldType.FHASH64:
      return WireType.FIXED64;
    case FieldType.STRING:
    case FieldType.MESSAGE:
    case FieldType.BYTES:
      return WireType.DELIMITED;
    case FieldType.FLOAT:
    case FieldType.FIXED32:
    case FieldType.SFIXED32:
      return WireType.FIXED32;
    case FieldType.INVALID:
    case FieldType.GROUP:
    default:
      return WireType.INVALID;
  }
};
var INVALID_FIELD_NUMBER = -1;
var FLOAT32_MIN = 11754943508222875e-54;
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT64_MIN = 22250738585072014e-324;
var FLOAT64_MAX = 17976931348623157e292;
var TWO_TO_20 = 1048576;
var TWO_TO_23 = 8388608;
var TWO_TO_31 = 2147483648;
var TWO_TO_32 = 4294967296;
var TWO_TO_52 = 4503599627370496;
var TWO_TO_63 = 9223372036854776e3;
var TWO_TO_64 = 18446744073709552e3;

// src/runtime/goog/crypt.ts
var decoder = new TextDecoder("utf8");
function byteArrayToString(bytes) {
  const buffer = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
  return decoder.decode(buffer);
}
var encoder = new TextEncoder();
function stringToUint8Array(s) {
  return encoder.encode(s);
}

// src/runtime/utils.ts
function byteSourceToUint8Array(data) {
  if (data instanceof Uint8Array) {
    return data;
  }
  if (typeof data === "string") {
    return stringToUint8Array(data);
  }
  return new Uint8Array(data);
}
function fromZigzag64(bitsLow, bitsHigh, convert) {
  const signFlipMask = -(bitsLow & 1);
  bitsLow = (bitsLow >>> 1 | bitsHigh << 31) ^ signFlipMask;
  bitsHigh = bitsHigh >>> 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
function toZigzag64(bitsLow, bitsHigh, convert) {
  const signFlipMask = bitsHigh >> 31;
  bitsHigh = (bitsHigh << 1 | bitsLow >>> 31) ^ signFlipMask;
  bitsLow = bitsLow << 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
var ZERO_CHAR_CODE_ = 48;
function decimalStringToHash64(dec) {
  assert(dec.length > 0);
  let minus = false;
  if (dec[0] === "-") {
    minus = true;
    dec = dec.slice(1);
  }
  const resultBytes = [0, 0, 0, 0, 0, 0, 0, 0];
  function muladd(m, c) {
    for (let i = 0; i < 8 && (m !== 1 || c > 0); i++) {
      const r = m * resultBytes[i] + c;
      resultBytes[i] = r & 255;
      c = r >>> 8;
    }
  }
  function neg() {
    for (let i = 0; i < 8; i++) {
      resultBytes[i] = ~resultBytes[i] & 255;
    }
  }
  for (let i = 0; i < dec.length; i++) {
    muladd(10, dec.charCodeAt(i) - ZERO_CHAR_CODE_);
  }
  if (minus) {
    neg();
    muladd(1, 1);
  }
  return byteArrayToString(resultBytes);
}
var split64Low = 0;
var split64High = 0;
var splitInt64 = function(value) {
  const sign = value < 0;
  value = Math.abs(value);
  let lowBits = value >>> 0;
  let highBits = Math.floor((value - lowBits) / TWO_TO_32);
  highBits = highBits >>> 0;
  if (sign) {
    highBits = ~highBits >>> 0;
    lowBits = ~lowBits >>> 0;
    lowBits += 1;
    if (lowBits > 4294967295) {
      lowBits = 0;
      highBits++;
      if (highBits > 4294967295)
        highBits = 0;
    }
  }
  split64Low = lowBits;
  split64High = highBits;
};
var splitUint64 = function(value) {
  const lowBits = value >>> 0;
  const highBits = Math.floor((value - lowBits) / TWO_TO_32) >>> 0;
  split64Low = lowBits;
  split64High = highBits;
};
var splitZigzag64 = function(value) {
  const sign = value < 0;
  value = Math.abs(value) * 2;
  splitUint64(value);
  let lowBits = split64Low;
  let highBits = split64High;
  if (sign) {
    if (lowBits == 0) {
      if (highBits == 0) {
        lowBits = 4294967295;
        highBits = 4294967295;
      } else {
        highBits--;
        lowBits = 4294967295;
      }
    } else {
      lowBits--;
    }
  }
  split64Low = lowBits;
  split64High = highBits;
};
var splitHash64 = function(hash) {
  const a = hash.charCodeAt(0);
  const b = hash.charCodeAt(1);
  const c = hash.charCodeAt(2);
  const d = hash.charCodeAt(3);
  const e = hash.charCodeAt(4);
  const f = hash.charCodeAt(5);
  const g = hash.charCodeAt(6);
  const h = hash.charCodeAt(7);
  split64Low = a + (b << 8) + (c << 16) + (d << 24) >>> 0;
  split64High = e + (f << 8) + (g << 16) + (h << 24) >>> 0;
};
var splitFloat32 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  let exp;
  let mant;
  if (value === 0) {
    if (1 / value > 0) {
      split64High = 0;
      split64Low = 0;
    } else {
      split64High = 0;
      split64Low = 2147483648;
    }
    return;
  }
  if (isNaN(value)) {
    split64High = 0;
    split64Low = 2147483647;
    return;
  }
  if (value > FLOAT32_MAX) {
    split64High = 0;
    split64Low = (sign << 31 | 2139095040) >>> 0;
    return;
  }
  if (value < FLOAT32_MIN) {
    mant = Math.round(value / Math.pow(2, -149));
    split64High = 0;
    split64Low = (sign << 31 | mant) >>> 0;
    return;
  }
  exp = Math.floor(Math.log(value) / Math.LN2);
  mant = value * Math.pow(2, -exp);
  mant = Math.round(mant * TWO_TO_23);
  if (mant >= 16777216) {
    ++exp;
  }
  mant = mant & 8388607;
  split64High = 0;
  split64Low = (sign << 31 | exp + 127 << 23 | mant) >>> 0;
};
var splitFloat64 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  if (value === 0) {
    if (1 / value > 0) {
      split64High = 0;
      split64Low = 0;
    } else {
      split64High = 2147483648;
      split64Low = 0;
    }
    return;
  }
  if (isNaN(value)) {
    split64High = 2147483647;
    split64Low = 4294967295;
    return;
  }
  if (value > FLOAT64_MAX) {
    split64High = (sign << 31 | 2146435072) >>> 0;
    split64Low = 0;
    return;
  }
  if (value < FLOAT64_MIN) {
    const mant2 = value / Math.pow(2, -1074);
    const mantHigh2 = mant2 / TWO_TO_32;
    split64High = (sign << 31 | mantHigh2) >>> 0;
    split64Low = mant2 >>> 0;
    return;
  }
  const maxDoubleExponent = 1023;
  const minDoubleExponent = -1022;
  let x = value;
  let exp = 0;
  if (x >= 2) {
    while (x >= 2 && exp < maxDoubleExponent) {
      exp++;
      x = x / 2;
    }
  } else {
    while (x < 1 && exp > minDoubleExponent) {
      x = x * 2;
      exp--;
    }
  }
  const mant = value * Math.pow(2, -exp);
  const mantHigh = mant * TWO_TO_20 & 1048575;
  const mantLow = mant * TWO_TO_52 >>> 0;
  split64High = (sign << 31 | exp + 1023 << 20 | mantHigh) >>> 0;
  split64Low = mantLow;
};
var joinUint64 = function(bitsLow, bitsHigh) {
  return bitsHigh * TWO_TO_32 + (bitsLow >>> 0);
};
var joinInt64 = function(bitsLow, bitsHigh) {
  const sign = bitsHigh & 2147483648;
  if (sign) {
    bitsLow = ~bitsLow + 1 >>> 0;
    bitsHigh = ~bitsHigh >>> 0;
    if (bitsLow == 0) {
      bitsHigh = bitsHigh + 1 >>> 0;
    }
  }
  const result = joinUint64(bitsLow, bitsHigh);
  return sign ? -result : result;
};
var joinZigzag64 = function(bitsLow, bitsHigh) {
  return fromZigzag64(bitsLow, bitsHigh, joinInt64);
};
var joinHash64 = function(bitsLow, bitsHigh) {
  const a = bitsLow >>> 0 & 255;
  const b = bitsLow >>> 8 & 255;
  const c = bitsLow >>> 16 & 255;
  const d = bitsLow >>> 24 & 255;
  const e = bitsHigh >>> 0 & 255;
  const f = bitsHigh >>> 8 & 255;
  const g = bitsHigh >>> 16 & 255;
  const h = bitsHigh >>> 24 & 255;
  return String.fromCharCode(a, b, c, d, e, f, g, h);
};
function joinFloat32(bitsLow) {
  const sign = (bitsLow >> 31) * 2 + 1;
  const exp = bitsLow >>> 23 & 255;
  const mant = bitsLow & 8388607;
  if (exp == 255) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -149) * mant;
  } else {
    return sign * Math.pow(2, exp - 150) * (mant + Math.pow(2, 23));
  }
}
var joinFloat64 = function(bitsLow, bitsHigh) {
  const sign = (bitsHigh >> 31) * 2 + 1;
  const exp = bitsHigh >>> 20 & 2047;
  const mant = TWO_TO_32 * (bitsHigh & 1048575) + bitsLow;
  if (exp == 2047) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -1074) * mant;
  } else {
    return sign * Math.pow(2, exp - 1075) * (mant + TWO_TO_52);
  }
};
var joinUnsignedDecimalString = function(bitsLow, bitsHigh) {
  if (bitsHigh <= 2097151) {
    return joinUint64(bitsLow, bitsHigh).toString();
  }
  const low = bitsLow & 16777215;
  const mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  const high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    const partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
};
var joinSignedDecimalString = function(bitsLow, bitsHigh) {
  const negative = bitsHigh & 2147483648;
  if (negative) {
    bitsLow = ~bitsLow + 1 >>> 0;
    const carry = bitsLow == 0 ? 1 : 0;
    bitsHigh = ~bitsHigh + carry >>> 0;
  }
  const result = joinUnsignedDecimalString(bitsLow, bitsHigh);
  return negative ? "-" + result : result;
};

// src/runtime/decoder.ts
var _BinaryDecoder = class {
  static alloc(opt_bytes, opt_start, opt_length) {
    const newDecoder = _BinaryDecoder.instanceCache_.pop();
    if (newDecoder) {
      if (opt_bytes) {
        newDecoder.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newDecoder;
    } else {
      return new _BinaryDecoder(opt_bytes, opt_start, opt_length);
    }
  }
  constructor(opt_bytes, opt_start, opt_length) {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
    if (opt_bytes) {
      this.setBlock(opt_bytes, opt_start, opt_length);
    }
  }
  free() {
    this.clear();
    if (_BinaryDecoder.instanceCache_.length < 100) {
      _BinaryDecoder.instanceCache_.push(this);
    }
  }
  clone() {
    return _BinaryDecoder.alloc(
      this.bytes_,
      this.start_,
      this.end_ - this.start_
    );
  }
  clear() {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
  }
  getBuffer() {
    return this.bytes_;
  }
  setBlock(data, opt_start, opt_length) {
    this.bytes_ = byteSourceToUint8Array(data);
    this.start_ = opt_start !== void 0 ? opt_start : 0;
    this.end_ = opt_length !== void 0 ? this.start_ + opt_length : this.bytes_.length;
    this.cursor_ = this.start_;
  }
  getEnd() {
    return this.end_;
  }
  setEnd(end) {
    this.end_ = end;
  }
  reset() {
    this.cursor_ = this.start_;
  }
  getCursor() {
    return this.cursor_;
  }
  setCursor(cursor) {
    this.cursor_ = cursor;
  }
  advance(count) {
    this.cursor_ += count;
    assert(this.cursor_ <= this.end_);
  }
  atEnd() {
    return this.cursor_ == this.end_;
  }
  pastEnd() {
    return this.cursor_ > this.end_;
  }
  getError() {
    return this.error_ || this.cursor_ < 0 || this.cursor_ > this.end_;
  }
  readSplitVarint64(convert) {
    let temp = 128;
    let lowBits = 0;
    let highBits = 0;
    for (let i = 0; i < 4 && temp >= 128; i++) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << i * 7;
    }
    if (temp >= 128) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << 28;
      highBits |= (temp & 127) >> 4;
    }
    if (temp >= 128) {
      for (let i = 0; i < 5 && temp >= 128; i++) {
        temp = this.bytes_[this.cursor_++];
        highBits |= (temp & 127) << i * 7 + 3;
      }
    }
    if (temp < 128) {
      return convert(lowBits >>> 0, highBits >>> 0);
    }
    fail("Failed to read varint, encoding is invalid.");
    this.error_ = true;
    return void 0;
  }
  readSplitFixed64(convert) {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    this.cursor_ += 8;
    let lowBits = 0;
    let highBits = 0;
    for (let i = cursor + 7; i >= cursor; i--) {
      lowBits = lowBits << 8 | bytes[i];
      highBits = highBits << 8 | bytes[i + 4];
    }
    return convert(lowBits, highBits);
  }
  skipVarint() {
    while (this.bytes_[this.cursor_] & 128) {
      this.cursor_++;
    }
    this.cursor_++;
  }
  unskipVarint(value) {
    while (value > 128) {
      this.cursor_--;
      value = value >>> 7;
    }
    this.cursor_--;
  }
  readUnsignedVarint32() {
    let temp;
    const bytes = this.bytes_;
    temp = bytes[this.cursor_ + 0];
    let x = temp & 127;
    if (temp < 128) {
      this.cursor_ += 1;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 1];
    x |= (temp & 127) << 7;
    if (temp < 128) {
      this.cursor_ += 2;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 2];
    x |= (temp & 127) << 14;
    if (temp < 128) {
      this.cursor_ += 3;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 3];
    x |= (temp & 127) << 21;
    if (temp < 128) {
      this.cursor_ += 4;
      assert(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 4];
    x |= (temp & 15) << 28;
    if (temp < 128) {
      this.cursor_ += 5;
      assert(this.cursor_ <= this.end_);
      return x >>> 0;
    }
    this.cursor_ += 5;
    if (bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128) {
      assert(false);
    }
    assert(this.cursor_ <= this.end_);
    return x;
  }
  readSignedVarint32() {
    return this.readUnsignedVarint32();
  }
  readUnsignedVarint32String() {
    const value = this.readUnsignedVarint32();
    return value.toString();
  }
  readSignedVarint32String() {
    const value = this.readSignedVarint32();
    return value.toString();
  }
  readZigzagVarint32() {
    const result = this.readUnsignedVarint32();
    return result >>> 1 ^ -(result & 1);
  }
  readUnsignedVarint64() {
    return this.readSplitVarint64(joinUint64);
  }
  readUnsignedVarint64String() {
    return this.readSplitVarint64(joinUnsignedDecimalString);
  }
  readSignedVarint64() {
    return this.readSplitVarint64(joinInt64);
  }
  readSignedVarint64String() {
    return this.readSplitVarint64(joinSignedDecimalString);
  }
  readZigzagVarint64() {
    return this.readSplitVarint64(joinZigzag64);
  }
  readSplitZigzagVarint64(convert) {
    return this.readSplitVarint64(function(low, high) {
      return fromZigzag64(low, high, convert);
    });
  }
  readZigzagVarintHash64() {
    return this.readSplitZigzagVarint64(joinHash64);
  }
  readZigzagVarint64String() {
    return this.readSplitZigzagVarint64(joinSignedDecimalString);
  }
  readUint8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert(this.cursor_ <= this.end_);
    return a;
  }
  readUint16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert(this.cursor_ <= this.end_);
    return a << 0 | b << 8;
  }
  readUint32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert(this.cursor_ <= this.end_);
    return (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
  }
  readUint64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUint64(bitsLow, bitsHigh);
  }
  readUint64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUnsignedDecimalString(bitsLow, bitsHigh);
  }
  readInt8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert(this.cursor_ <= this.end_);
    return a << 24 >> 24;
  }
  readInt16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert(this.cursor_ <= this.end_);
    return (a << 0 | b << 8) << 16 >> 16;
  }
  readInt32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert(this.cursor_ <= this.end_);
    return a << 0 | b << 8 | c << 16 | d << 24;
  }
  readInt64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinInt64(bitsLow, bitsHigh);
  }
  readInt64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinSignedDecimalString(bitsLow, bitsHigh);
  }
  readFloat() {
    const bitsLow = this.readUint32();
    return joinFloat32(bitsLow);
  }
  readDouble() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinFloat64(bitsLow, bitsHigh);
  }
  readBool() {
    return !!this.bytes_[this.cursor_++];
  }
  readEnum() {
    return this.readSignedVarint32();
  }
  readString(length) {
    return byteArrayToString(this.readBytes(length));
  }
  readStringWithLength() {
    const length = this.readUnsignedVarint32();
    return this.readString(length);
  }
  readBytes(length) {
    if (length < 0 || this.cursor_ + length > this.bytes_.length) {
      this.error_ = true;
      fail("Invalid byte length!");
      return new Uint8Array(0);
    }
    const result = this.bytes_.subarray(this.cursor_, this.cursor_ + length);
    this.cursor_ += length;
    assert(this.cursor_ <= this.end_);
    return result;
  }
  readVarintHash64() {
    return this.readSplitVarint64(joinHash64);
  }
  readFixedHash64() {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    const a = bytes[cursor + 0];
    const b = bytes[cursor + 1];
    const c = bytes[cursor + 2];
    const d = bytes[cursor + 3];
    const e = bytes[cursor + 4];
    const f = bytes[cursor + 5];
    const g = bytes[cursor + 6];
    const h = bytes[cursor + 7];
    this.cursor_ += 8;
    return String.fromCharCode(a, b, c, d, e, f, g, h);
  }
};
var BinaryDecoder = _BinaryDecoder;
BinaryDecoder.instanceCache_ = [];

// src/runtime/reader.ts
var _BinaryReader = class {
  static alloc(opt_bytes, opt_start, opt_length) {
    const newReader = _BinaryReader.instanceCache_.pop();
    if (newReader) {
      if (opt_bytes) {
        newReader.decoder_.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newReader;
    } else {
      return new _BinaryReader(opt_bytes, opt_start, opt_length);
    }
  }
  constructor(opt_bytes = void 0, opt_start = void 0, opt_length = void 0) {
    this.decoder_ = BinaryDecoder.alloc(opt_bytes, opt_start, opt_length);
    this.fieldCursor_ = this.decoder_.getCursor();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
  }
  free() {
    this.decoder_.clear();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
    if (_BinaryReader.instanceCache_.length < 100) {
      _BinaryReader.instanceCache_.push(this);
    }
  }
  getFieldCursor() {
    return this.fieldCursor_;
  }
  getCursor() {
    return this.decoder_.getCursor();
  }
  getBuffer() {
    return this.decoder_.getBuffer();
  }
  getFieldNumber() {
    return this.nextField_;
  }
  getWireType() {
    return this.nextWireType_;
  }
  isDelimited() {
    return this.nextWireType_ == WireType.DELIMITED;
  }
  isEndGroup() {
    return this.nextWireType_ == WireType.END_GROUP;
  }
  getError() {
    return this.error_ || this.decoder_.getError();
  }
  setBlock(bytes, start, length) {
    this.decoder_.setBlock(bytes, start, length);
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
  }
  reset() {
    this.decoder_.reset();
    this.nextField_ = INVALID_FIELD_NUMBER;
    this.nextWireType_ = WireType.INVALID;
  }
  advance(count) {
    this.decoder_.advance(count);
  }
  nextField() {
    if (this.decoder_.atEnd()) {
      return false;
    }
    if (this.getError()) {
      fail("Decoder hit an error");
      return false;
    }
    this.fieldCursor_ = this.decoder_.getCursor();
    const header = this.decoder_.readUnsignedVarint32();
    const nextField = header >>> 3;
    const nextWireType = header & 7;
    if (nextWireType != WireType.VARINT && nextWireType != WireType.FIXED32 && nextWireType != WireType.FIXED64 && nextWireType != WireType.DELIMITED && nextWireType != WireType.START_GROUP && nextWireType != WireType.END_GROUP) {
      fail(
        `Invalid wire type: ${nextWireType} (at position ${this.fieldCursor_})`
      );
      this.error_ = true;
      return false;
    }
    this.nextField_ = nextField;
    this.nextWireType_ = nextWireType;
    return true;
  }
  unskipHeader() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }
  skipMatchingFields() {
    const field = this.nextField_;
    this.unskipHeader();
    while (this.nextField() && this.getFieldNumber() == field) {
      this.skipField();
    }
    if (!this.decoder_.atEnd()) {
      this.unskipHeader();
    }
  }
  skipVarintField() {
    if (this.nextWireType_ != WireType.VARINT) {
      fail("Invalid wire type for skipVarintField");
      this.skipField();
      return;
    }
    this.decoder_.skipVarint();
  }
  skipDelimitedField() {
    if (this.nextWireType_ != WireType.DELIMITED) {
      fail("Invalid wire type for skipDelimitedField");
      this.skipField();
      return;
    }
    const length = this.decoder_.readUnsignedVarint32();
    this.decoder_.advance(length);
  }
  skipFixed32Field() {
    if (this.nextWireType_ != WireType.FIXED32) {
      fail("Invalid wire type for skipFixed32Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(4);
  }
  skipFixed64Field() {
    if (this.nextWireType_ != WireType.FIXED64) {
      fail("Invalid wire type for skipFixed64Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(8);
  }
  skipGroup() {
    const previousField = this.nextField_;
    while (true) {
      if (!this.nextField()) {
        fail("Unmatched start-group tag: stream EOF");
        this.error_ = true;
        return;
      }
      if (this.nextWireType_ == WireType.END_GROUP) {
        if (this.nextField_ != previousField) {
          fail("Unmatched end-group tag");
          this.error_ = true;
          return;
        }
        return;
      }
      this.skipField();
    }
  }
  skipField() {
    switch (this.nextWireType_) {
      case WireType.VARINT:
        this.skipVarintField();
        break;
      case WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        fail("Invalid wire encoding for field.");
    }
  }
  registerReadCallback(callbackName, callback) {
    assert(!this.readCallbacks_[callbackName]);
    this.readCallbacks_[callbackName] = callback;
  }
  runReadCallback(callbackName) {
    const callback = this.readCallbacks_[callbackName];
    assert(!!callback);
    return callback(this);
  }
  readAny(fieldType) {
    this.nextWireType_ = FieldTypeToWireType(fieldType);
    switch (fieldType) {
      case FieldType.DOUBLE:
        return this.readDouble();
      case FieldType.FLOAT:
        return this.readFloat();
      case FieldType.INT64:
        return this.readInt64();
      case FieldType.UINT64:
        return this.readUint64();
      case FieldType.INT32:
        return this.readInt32();
      case FieldType.FIXED64:
        return this.readFixed64();
      case FieldType.FIXED32:
        return this.readFixed32();
      case FieldType.BOOL:
        return this.readBool();
      case FieldType.STRING:
        return this.readString();
      case FieldType.GROUP:
        fail("Group field type not supported in readAny()");
        break;
      case FieldType.MESSAGE:
        fail("Message field type not supported in readAny()");
        break;
      case FieldType.BYTES:
        return this.readBytes();
      case FieldType.UINT32:
        return this.readUint32();
      case FieldType.ENUM:
        return this.readEnum();
      case FieldType.SFIXED32:
        return this.readSfixed32();
      case FieldType.SFIXED64:
        return this.readSfixed64();
      case FieldType.SINT32:
        return this.readSint32();
      case FieldType.SINT64:
        return this.readSint64();
      case FieldType.FHASH64:
        return this.readFixedHash64();
      case FieldType.VHASH64:
        return this.readVarintHash64();
      default:
        fail("Invalid field type in readAny()");
    }
    return 0;
  }
  readMessage(message, reader) {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const oldEnd = this.decoder_.getEnd();
    const length = this.decoder_.readUnsignedVarint32();
    const newEnd = this.decoder_.getCursor() + length;
    this.decoder_.setEnd(newEnd);
    reader(message, this);
    this.decoder_.setCursor(newEnd);
    this.decoder_.setEnd(oldEnd);
  }
  readGroup(field, message, reader) {
    assert(this.nextWireType_ == WireType.START_GROUP);
    assert(this.nextField_ == field);
    reader(message, this);
    if (!this.error_ && this.nextWireType_ != WireType.END_GROUP) {
      fail("Group submessage did not end with an END_GROUP tag");
      this.error_ = true;
    }
  }
  getFieldDecoder() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const start = this.decoder_.getCursor();
    const end = start + length;
    const innerDecoder = BinaryDecoder.alloc(
      this.decoder_.getBuffer(),
      start,
      length
    );
    this.decoder_.setCursor(end);
    return innerDecoder;
  }
  readInt32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint32();
  }
  readInt32String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint32String();
  }
  readInt64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  readInt64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64String();
  }
  readUint32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint32();
  }
  readUint32String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint32String();
  }
  readUint64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint64();
  }
  readUint64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readUnsignedVarint64String();
  }
  readSint32() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint32();
  }
  readSint64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint64();
  }
  readSint64String() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarint64String();
  }
  readFixed32() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readUint32();
  }
  readFixed64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readUint64();
  }
  readFixed64String() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readUint64String();
  }
  readSfixed32() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readInt32();
  }
  readSfixed32String() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readInt32().toString();
  }
  readSfixed64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readInt64();
  }
  readSfixed64String() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readInt64String();
  }
  readFloat() {
    assert(this.nextWireType_ == WireType.FIXED32);
    return this.decoder_.readFloat();
  }
  readDouble() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readDouble();
  }
  readBool() {
    assert(this.nextWireType_ == WireType.VARINT);
    return !!this.decoder_.readUnsignedVarint32();
  }
  readEnum() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  readString() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(length);
  }
  readBytes() {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(length);
  }
  readVarintHash64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readVarintHash64();
  }
  readSintHash64() {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readZigzagVarintHash64();
  }
  readSplitVarint64(convert) {
    assert(this.nextWireType_ == WireType.VARINT);
    return this.decoder_.readSplitVarint64(convert);
  }
  readFixedHash64() {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readFixedHash64();
  }
  readSplitFixed64(convert) {
    assert(this.nextWireType_ == WireType.FIXED64);
    return this.decoder_.readSplitFixed64(convert);
  }
  readPackedField_(decodeMethod) {
    assert(this.nextWireType_ == WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const end = this.decoder_.getCursor() + length;
    const result = [];
    while (this.decoder_.getCursor() < end) {
      result.push(decodeMethod.call(this.decoder_));
    }
    return result;
  }
  readPackedInt32() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }
  readPackedInt32String() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }
  readPackedInt64() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }
  readPackedInt64String() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }
  readPackedUint32() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }
  readPackedUint32String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }
  readPackedUint64() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }
  readPackedUint64String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }
  readPackedSint32() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }
  readPackedSint64() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }
  readPackedSint64String() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }
  readPackedFixed32() {
    return this.readPackedField_(this.decoder_.readUint32);
  }
  readPackedFixed64() {
    return this.readPackedField_(this.decoder_.readUint64);
  }
  readPackedFixed64String() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }
  readPackedSfixed32() {
    return this.readPackedField_(this.decoder_.readInt32);
  }
  readPackedSfixed64() {
    return this.readPackedField_(this.decoder_.readInt64);
  }
  readPackedSfixed64String() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }
  readPackedFloat() {
    return this.readPackedField_(this.decoder_.readFloat);
  }
  readPackedDouble() {
    return this.readPackedField_(this.decoder_.readDouble);
  }
  readPackedBool() {
    return this.readPackedField_(this.decoder_.readBool);
  }
  readPackedEnum() {
    return this.readPackedField_(this.decoder_.readEnum);
  }
  readPackedVarintHash64() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }
  readPackedFixedHash64() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }
};
var BinaryReader = _BinaryReader;
BinaryReader.instanceCache_ = [];

// src/runtime/encoder.ts
var BinaryEncoder = class {
  constructor() {
    this.buffer_ = [];
  }
  length() {
    return this.buffer_.length;
  }
  end() {
    const buffer = this.buffer_;
    this.buffer_ = [];
    return buffer;
  }
  writeSplitVarint64(lowBits, highBits) {
    assert(lowBits == Math.floor(lowBits));
    assert(highBits == Math.floor(highBits));
    assert(lowBits >= 0 && lowBits < TWO_TO_32);
    assert(highBits >= 0 && highBits < TWO_TO_32);
    while (highBits > 0 || lowBits > 127) {
      this.buffer_.push(lowBits & 127 | 128);
      lowBits = (lowBits >>> 7 | highBits << 25) >>> 0;
      highBits = highBits >>> 7;
    }
    this.buffer_.push(lowBits);
  }
  writeSplitFixed64(lowBits, highBits) {
    assert(lowBits == Math.floor(lowBits));
    assert(highBits == Math.floor(highBits));
    assert(lowBits >= 0 && lowBits < TWO_TO_32);
    assert(highBits >= 0 && highBits < TWO_TO_32);
    this.writeUint32(lowBits);
    this.writeUint32(highBits);
  }
  writeUnsignedVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_32);
    while (value > 127) {
      this.buffer_.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buffer_.push(value);
  }
  writeSignedVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    if (value >= 0) {
      this.writeUnsignedVarint32(value);
      return;
    }
    for (let i = 0; i < 9; i++) {
      this.buffer_.push(value & 127 | 128);
      value = value >> 7;
    }
    this.buffer_.push(1);
  }
  writeUnsignedVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_64);
    splitInt64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  writeSignedVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitInt64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  writeZigzagVarint32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeUnsignedVarint32((value << 1 ^ value >> 31) >>> 0);
  }
  writeZigzagVarint64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitZigzag64(value);
    this.writeSplitVarint64(split64Low, split64High);
  }
  writeZigzagVarint64String(value) {
    this.writeZigzagVarintHash64(decimalStringToHash64(value));
  }
  writeZigzagVarintHash64(hash) {
    splitHash64(hash);
    toZigzag64(split64Low, split64High, (lo, hi) => {
      this.writeSplitVarint64(lo >>> 0, hi >>> 0);
    });
  }
  writeUint8(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < 256);
    this.buffer_.push(value >>> 0 & 255);
  }
  writeUint16(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < 65536);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  writeUint32(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_32);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  writeUint64(value) {
    assert(value == Math.floor(value));
    assert(value >= 0 && value < TWO_TO_64);
    splitUint64(value);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  writeInt8(value) {
    assert(value == Math.floor(value));
    assert(value >= -128 && value < 128);
    this.buffer_.push(value >>> 0 & 255);
  }
  writeInt16(value) {
    assert(value == Math.floor(value));
    assert(value >= -32768 && value < 32768);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  writeInt32(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  writeInt64(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    splitInt64(value);
    this.writeSplitFixed64(split64Low, split64High);
  }
  writeInt64String(value) {
    assert(
      value == Math.floor(value)
    );
    assert(+value >= -TWO_TO_63 && +value < TWO_TO_63);
    splitHash64(decimalStringToHash64(value));
    this.writeSplitFixed64(split64Low, split64High);
  }
  writeFloat(value) {
    assert(
      value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT32_MAX && value <= FLOAT32_MAX
    );
    splitFloat32(value);
    this.writeUint32(split64Low);
  }
  writeDouble(value) {
    assert(
      value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT64_MAX && value <= FLOAT64_MAX
    );
    splitFloat64(value);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  writeBool(value) {
    assert(typeof value === "boolean" || typeof value === "number");
    this.buffer_.push(value ? 1 : 0);
  }
  writeEnum(value) {
    assert(value == Math.floor(value));
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeSignedVarint32(value);
  }
  writeBytes(bytes) {
    this.buffer_.push(...bytes);
  }
  writeVarintHash64(hash) {
    splitHash64(hash);
    this.writeSplitVarint64(split64Low, split64High);
  }
  writeFixedHash64(hash) {
    splitHash64(hash);
    this.writeUint32(split64Low);
    this.writeUint32(split64High);
  }
  writeString(value) {
    const oldLength = this.buffer_.length;
    const buffer = stringToUint8Array(value);
    buffer.forEach((val) => this.buffer_.push(val));
    const length = this.buffer_.length - oldLength;
    return length;
  }
};

// src/runtime/arith.ts
var UInt64 = class {
  constructor(bigint, lo, hi) {
    this.bigint = bigint;
    this.lo = lo;
    this.hi = hi;
  }
  toString() {
    return this.bigint.toString();
  }
  static fromString(s) {
    const bigint = BigInt.asUintN(64, BigInt(s));
    const lo = Number(BigInt.asUintN(32, bigint));
    const hi = Number(bigint >> BigInt(32));
    return new UInt64(bigint, lo, hi);
  }
};
var Int64 = class extends UInt64 {
  static fromString(s) {
    const bigint = BigInt.asIntN(64, BigInt(s));
    const { lo, hi } = UInt64.fromString(s);
    return new Int64(bigint, lo, hi);
  }
};

// src/runtime/writer.ts
var BinaryWriter = class {
  constructor() {
    this.blocks_ = [];
    this.totalLength_ = 0;
    this.encoder_ = new BinaryEncoder();
  }
  appendUint8Array_(arr) {
    const temp = this.encoder_.end();
    this.blocks_.push(temp);
    this.blocks_.push(arr);
    this.totalLength_ += temp.length + arr.length;
  }
  beginDelimited_(field) {
    this.writeFieldHeader_(field, WireType.DELIMITED);
    const bookmark = this.encoder_.end();
    this.blocks_.push(bookmark);
    this.totalLength_ += bookmark.length;
    bookmark.push(this.totalLength_);
    return bookmark;
  }
  endDelimited_(bookmark) {
    const oldLength = bookmark.pop() ?? 0;
    let messageLength = this.totalLength_ + this.encoder_.length() - oldLength;
    assert(messageLength >= 0);
    while (messageLength > 127) {
      bookmark.push(messageLength & 127 | 128);
      messageLength = messageLength >>> 7;
      this.totalLength_++;
    }
    bookmark.push(messageLength);
    this.totalLength_++;
  }
  writeSerializedMessage(bytes, start, end) {
    this.appendUint8Array_(bytes.subarray(start, end));
  }
  maybeWriteSerializedMessage(bytes, start, end) {
    if (bytes != null && start != null && end != null) {
      this.writeSerializedMessage(bytes, start, end);
    }
  }
  reset() {
    this.blocks_ = [];
    this.encoder_.end();
    this.totalLength_ = 0;
  }
  getResultBuffer() {
    const flat = new Uint8Array(this.totalLength_ + this.encoder_.length());
    const blocks = this.blocks_;
    const blockCount = blocks.length;
    let offset = 0;
    for (let i = 0; i < blockCount; i++) {
      const block = blocks[i];
      flat.set(block, offset);
      offset += block.length;
    }
    const tail = this.encoder_.end();
    flat.set(tail, offset);
    offset += tail.length;
    assert(offset == flat.length);
    this.blocks_ = [flat];
    return flat;
  }
  writeFieldHeader_(field, wireType) {
    assert(field >= 1 && field == Math.floor(field));
    const x = field * 8 + wireType;
    this.encoder_.writeUnsignedVarint32(x);
  }
  writeAny(fieldType, field, value) {
    switch (fieldType) {
      case FieldType.DOUBLE:
        this.writeDouble(field, value);
        return;
      case FieldType.FLOAT:
        this.writeFloat(field, value);
        return;
      case FieldType.INT64:
        this.writeInt64(field, value);
        return;
      case FieldType.UINT64:
        this.writeUint64(field, value);
        return;
      case FieldType.INT32:
        this.writeInt32(field, value);
        return;
      case FieldType.FIXED64:
        this.writeFixed64(field, value);
        return;
      case FieldType.FIXED32:
        this.writeFixed32(field, value);
        return;
      case FieldType.BOOL:
        this.writeBool(field, value);
        return;
      case FieldType.STRING:
        this.writeString(field, value);
        return;
      case FieldType.GROUP:
        fail("Group field type not supported in writeAny()");
        return;
      case FieldType.MESSAGE:
        fail("Message field type not supported in writeAny()");
        return;
      case FieldType.BYTES:
        this.writeBytes(field, value);
        return;
      case FieldType.UINT32:
        this.writeUint32(field, value);
        return;
      case FieldType.ENUM:
        this.writeEnum(field, value);
        return;
      case FieldType.SFIXED32:
        this.writeSfixed32(field, value);
        return;
      case FieldType.SFIXED64:
        this.writeSfixed64(field, value);
        return;
      case FieldType.SINT32:
        this.writeSint32(field, value);
        return;
      case FieldType.SINT64:
        this.writeSint64(field, value);
        return;
      case FieldType.FHASH64:
        this.writeFixedHash64(field, value);
        return;
      case FieldType.VHASH64:
        this.writeVarintHash64(field, value);
        return;
      default:
        fail("Invalid field type in writeAny()");
        return;
    }
  }
  writeUnsignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint32(value);
  }
  writeSignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  writeUnsignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint64(value);
  }
  writeSignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint64(value);
  }
  writeZigzagVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint32(value);
  }
  writeZigzagVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64(value);
  }
  writeZigzagVarint64String_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64String(value);
  }
  writeZigzagVarintHash64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarintHash64(value);
  }
  writeInt32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeSignedVarint32_(field, value);
  }
  writeInt32String(field, value) {
    if (value == null)
      return;
    const intValue = parseInt(value, 10);
    assert(intValue >= -TWO_TO_31 && intValue < TWO_TO_31);
    this.writeSignedVarint32_(field, intValue);
  }
  writeInt64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeSignedVarint64_(field, value);
  }
  writeInt64String(field, value) {
    if (value == null)
      return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  writeUint32(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_32);
    this.writeUnsignedVarint32_(field, value);
  }
  writeUint32String(field, value) {
    if (value == null)
      return;
    const intValue = parseInt(value, 10);
    assert(intValue >= 0 && intValue < TWO_TO_32);
    this.writeUnsignedVarint32_(field, intValue);
  }
  writeUint64(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_64);
    this.writeUnsignedVarint64_(field, value);
  }
  writeUint64String(field, value) {
    if (value == null)
      return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  writeSint32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeZigzagVarint32_(field, value);
  }
  writeSint64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeZigzagVarint64_(field, value);
  }
  writeSintHash64(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarintHash64_(field, value);
  }
  writeSint64String(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarint64String_(field, value);
  }
  writeFixed32(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_32);
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeUint32(value);
  }
  writeFixed64(field, value) {
    if (value == null)
      return;
    assert(value >= 0 && value < TWO_TO_64);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeUint64(value);
  }
  writeFixed64String(field, value) {
    if (value == null)
      return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  writeSfixed32(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeInt32(value);
  }
  writeSfixed64(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_63 && value < TWO_TO_63);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeInt64(value);
  }
  writeSfixed64String(field, value) {
    if (value == null)
      return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  writeFloat(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeFloat(value);
  }
  writeDouble(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeDouble(value);
  }
  writeBool(field, value) {
    if (value == null)
      return;
    assert(typeof value === "boolean" || typeof value === "number");
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeBool(value);
  }
  writeEnum(field, value) {
    if (value == null)
      return;
    assert(value >= -TWO_TO_31 && value < TWO_TO_31);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  writeString(field, value) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    this.encoder_.writeString(value);
    this.endDelimited_(bookmark);
  }
  writeBytes(field, value) {
    if (value == null)
      return;
    const bytes = byteSourceToUint8Array(value);
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(bytes.length);
    this.appendUint8Array_(bytes);
  }
  writeMessage(field, value, writerCallback) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
  }
  writeMessageSet(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(1, WireType.START_GROUP);
    this.writeFieldHeader_(2, WireType.VARINT);
    this.encoder_.writeSignedVarint32(field);
    const bookmark = this.beginDelimited_(3);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
    this.writeFieldHeader_(1, WireType.END_GROUP);
  }
  writeGroup(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType.START_GROUP);
    writerCallback(value, this);
    this.writeFieldHeader_(field, WireType.END_GROUP);
  }
  writeFixedHash64(field, value) {
    if (value == null)
      return;
    assert(value.length == 8);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeFixedHash64(value);
  }
  writeVarintHash64(field, value) {
    if (value == null)
      return;
    assert(value.length == 8);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeVarintHash64(value);
  }
  writeSplitFixed64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(lowBits, highBits);
  }
  writeSplitVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(lowBits, highBits);
  }
  writeSplitZigzagVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    const encoder3 = this.encoder_;
    toZigzag64(lowBits, highBits, function(lowBits2, highBits2) {
      encoder3.writeSplitVarint64(lowBits2 >>> 0, highBits2 >>> 0);
    });
  }
  writeRepeatedInt32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint32_(field, value[i]);
    }
  }
  writeRepeatedInt32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt32String(field, value[i]);
    }
  }
  writeRepeatedInt64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint64_(field, value[i]);
    }
  }
  writeRepeatedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitFixed64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitZigzagVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedInt64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt64String(field, value[i]);
    }
  }
  writeRepeatedUint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint32_(field, value[i]);
    }
  }
  writeRepeatedUint32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint32String(field, value[i]);
    }
  }
  writeRepeatedUint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint64_(field, value[i]);
    }
  }
  writeRepeatedUint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint64String(field, value[i]);
    }
  }
  writeRepeatedSint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint32_(field, value[i]);
    }
  }
  writeRepeatedSint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64_(field, value[i]);
    }
  }
  writeRepeatedSint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64String_(field, value[i]);
    }
  }
  writeRepeatedSintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarintHash64_(field, value[i]);
    }
  }
  writeRepeatedFixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed32(field, value[i]);
    }
  }
  writeRepeatedFixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64(field, value[i]);
    }
  }
  writeRepeatedFixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64String(field, value[i]);
    }
  }
  writeRepeatedSfixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed32(field, value[i]);
    }
  }
  writeRepeatedSfixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64(field, value[i]);
    }
  }
  writeRepeatedSfixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64String(field, value[i]);
    }
  }
  writeRepeatedFloat(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFloat(field, value[i]);
    }
  }
  writeRepeatedDouble(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeDouble(field, value[i]);
    }
  }
  writeRepeatedBool(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBool(field, value[i]);
    }
  }
  writeRepeatedEnum(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeEnum(field, value[i]);
    }
  }
  writeRepeatedString(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeString(field, value[i]);
    }
  }
  writeRepeatedBytes(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBytes(field, value[i]);
    }
  }
  writeRepeatedMessage(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      const bookmark = this.beginDelimited_(field);
      writerCallback(value[i], this);
      this.endDelimited_(bookmark);
    }
  }
  writeRepeatedGroup(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFieldHeader_(field, WireType.START_GROUP);
      writerCallback(value[i], this);
      this.writeFieldHeader_(field, WireType.END_GROUP);
    }
  }
  writeRepeatedFixedHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixedHash64(field, value[i]);
    }
  }
  writeRepeatedVarintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeVarintHash64(field, value[i]);
    }
  }
  writePackedInt32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt32String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitFixed64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitVarint64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    const encoder3 = this.encoder_;
    for (let i = 0; i < value.length; i++) {
      toZigzag64(lo(value[i]), hi(value[i]), function(bitsLow, bitsHigh) {
        encoder3.writeSplitVarint64(bitsLow >>> 0, bitsHigh >>> 0);
      });
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = Int64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint32String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(decimalStringToHash64(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSintHash64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedFixed32(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint32(value[i]);
    }
  }
  writePackedFixed64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint64(value[i]);
    }
  }
  writePackedFixed64String(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitFixed64(num.lo, num.hi);
    }
  }
  writePackedSfixed32(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt32(value[i]);
    }
  }
  writePackedSfixed64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64(value[i]);
    }
  }
  writePackedSfixed64String(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64String(value[i]);
    }
  }
  writePackedFloat(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFloat(value[i]);
    }
  }
  writePackedDouble(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeDouble(value[i]);
    }
  }
  writePackedBool(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeBool(value[i]);
    }
  }
  writePackedEnum(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeEnum(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedFixedHash64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFixedHash64(value[i]);
    }
  }
  writePackedVarintHash64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
};

// src/runtime/json.ts
function encodeBase64Bytes(bytes) {
  return btoa(byteArrayToString(bytes));
}
function decodeBase64Bytes(bytes) {
  return stringToUint8Array(atob(bytes));
}

// node_modules/protoscript/runtime/goog/asserts.js
var assert2 = (condition) => {
  if (!condition) {
    throw new Error("Assertion failed");
  }
  return condition;
};
var fail2 = (message) => {
  throw new Error(message);
};

// node_modules/protoscript/runtime/constants.js
var FieldType2 = {
  INVALID: -1,
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18,
  FHASH64: 30,
  VHASH64: 31
};
var WireType2 = {
  INVALID: -1,
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};
var FieldTypeToWireType2 = function(fieldType) {
  switch (fieldType) {
    case FieldType2.INT32:
    case FieldType2.INT64:
    case FieldType2.UINT32:
    case FieldType2.UINT64:
    case FieldType2.SINT32:
    case FieldType2.SINT64:
    case FieldType2.BOOL:
    case FieldType2.ENUM:
    case FieldType2.VHASH64:
      return WireType2.VARINT;
    case FieldType2.DOUBLE:
    case FieldType2.FIXED64:
    case FieldType2.SFIXED64:
    case FieldType2.FHASH64:
      return WireType2.FIXED64;
    case FieldType2.STRING:
    case FieldType2.MESSAGE:
    case FieldType2.BYTES:
      return WireType2.DELIMITED;
    case FieldType2.FLOAT:
    case FieldType2.FIXED32:
    case FieldType2.SFIXED32:
      return WireType2.FIXED32;
    case FieldType2.INVALID:
    case FieldType2.GROUP:
    default:
      return WireType2.INVALID;
  }
};
var INVALID_FIELD_NUMBER2 = -1;
var FLOAT32_MIN2 = 11754943508222875e-54;
var FLOAT32_MAX2 = 34028234663852886e22;
var FLOAT64_MIN2 = 22250738585072014e-324;
var FLOAT64_MAX2 = 17976931348623157e292;
var TWO_TO_202 = 1048576;
var TWO_TO_232 = 8388608;
var TWO_TO_312 = 2147483648;
var TWO_TO_322 = 4294967296;
var TWO_TO_522 = 4503599627370496;
var TWO_TO_632 = 9223372036854776e3;
var TWO_TO_642 = 18446744073709552e3;

// node_modules/protoscript/runtime/goog/crypt.js
var decoder2 = new TextDecoder("utf8");
function byteArrayToString2(bytes) {
  const buffer = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
  return decoder2.decode(buffer);
}
var encoder2 = new TextEncoder();
function stringToUint8Array2(s) {
  return encoder2.encode(s);
}

// node_modules/protoscript/runtime/utils.js
function byteSourceToUint8Array2(data) {
  if (data instanceof Uint8Array) {
    return data;
  }
  if (typeof data === "string") {
    return stringToUint8Array2(data);
  }
  return new Uint8Array(data);
}
function fromZigzag642(bitsLow, bitsHigh, convert) {
  const signFlipMask = -(bitsLow & 1);
  bitsLow = (bitsLow >>> 1 | bitsHigh << 31) ^ signFlipMask;
  bitsHigh = bitsHigh >>> 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
function toZigzag642(bitsLow, bitsHigh, convert) {
  const signFlipMask = bitsHigh >> 31;
  bitsHigh = (bitsHigh << 1 | bitsLow >>> 31) ^ signFlipMask;
  bitsLow = bitsLow << 1 ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}
var ZERO_CHAR_CODE_2 = 48;
function decimalStringToHash642(dec) {
  assert2(dec.length > 0);
  let minus = false;
  if (dec[0] === "-") {
    minus = true;
    dec = dec.slice(1);
  }
  const resultBytes = [0, 0, 0, 0, 0, 0, 0, 0];
  function muladd(m, c) {
    for (let i = 0; i < 8 && (m !== 1 || c > 0); i++) {
      const r = m * resultBytes[i] + c;
      resultBytes[i] = r & 255;
      c = r >>> 8;
    }
  }
  function neg() {
    for (let i = 0; i < 8; i++) {
      resultBytes[i] = ~resultBytes[i] & 255;
    }
  }
  for (let i = 0; i < dec.length; i++) {
    muladd(10, dec.charCodeAt(i) - ZERO_CHAR_CODE_2);
  }
  if (minus) {
    neg();
    muladd(1, 1);
  }
  return byteArrayToString2(resultBytes);
}
var split64Low2 = 0;
var split64High2 = 0;
var splitInt642 = function(value) {
  const sign = value < 0;
  value = Math.abs(value);
  let lowBits = value >>> 0;
  let highBits = Math.floor((value - lowBits) / TWO_TO_322);
  highBits = highBits >>> 0;
  if (sign) {
    highBits = ~highBits >>> 0;
    lowBits = ~lowBits >>> 0;
    lowBits += 1;
    if (lowBits > 4294967295) {
      lowBits = 0;
      highBits++;
      if (highBits > 4294967295)
        highBits = 0;
    }
  }
  split64Low2 = lowBits;
  split64High2 = highBits;
};
var splitUint642 = function(value) {
  const lowBits = value >>> 0;
  const highBits = Math.floor((value - lowBits) / TWO_TO_322) >>> 0;
  split64Low2 = lowBits;
  split64High2 = highBits;
};
var splitZigzag642 = function(value) {
  const sign = value < 0;
  value = Math.abs(value) * 2;
  splitUint642(value);
  let lowBits = split64Low2;
  let highBits = split64High2;
  if (sign) {
    if (lowBits == 0) {
      if (highBits == 0) {
        lowBits = 4294967295;
        highBits = 4294967295;
      } else {
        highBits--;
        lowBits = 4294967295;
      }
    } else {
      lowBits--;
    }
  }
  split64Low2 = lowBits;
  split64High2 = highBits;
};
var splitHash642 = function(hash) {
  const a = hash.charCodeAt(0);
  const b = hash.charCodeAt(1);
  const c = hash.charCodeAt(2);
  const d = hash.charCodeAt(3);
  const e = hash.charCodeAt(4);
  const f = hash.charCodeAt(5);
  const g = hash.charCodeAt(6);
  const h = hash.charCodeAt(7);
  split64Low2 = a + (b << 8) + (c << 16) + (d << 24) >>> 0;
  split64High2 = e + (f << 8) + (g << 16) + (h << 24) >>> 0;
};
var splitFloat322 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  let exp;
  let mant;
  if (value === 0) {
    if (1 / value > 0) {
      split64High2 = 0;
      split64Low2 = 0;
    } else {
      split64High2 = 0;
      split64Low2 = 2147483648;
    }
    return;
  }
  if (isNaN(value)) {
    split64High2 = 0;
    split64Low2 = 2147483647;
    return;
  }
  if (value > FLOAT32_MAX2) {
    split64High2 = 0;
    split64Low2 = (sign << 31 | 2139095040) >>> 0;
    return;
  }
  if (value < FLOAT32_MIN2) {
    mant = Math.round(value / Math.pow(2, -149));
    split64High2 = 0;
    split64Low2 = (sign << 31 | mant) >>> 0;
    return;
  }
  exp = Math.floor(Math.log(value) / Math.LN2);
  mant = value * Math.pow(2, -exp);
  mant = Math.round(mant * TWO_TO_232);
  if (mant >= 16777216) {
    ++exp;
  }
  mant = mant & 8388607;
  split64High2 = 0;
  split64Low2 = (sign << 31 | exp + 127 << 23 | mant) >>> 0;
};
var splitFloat642 = function(value) {
  const sign = value < 0 ? 1 : 0;
  value = sign ? -value : value;
  if (value === 0) {
    if (1 / value > 0) {
      split64High2 = 0;
      split64Low2 = 0;
    } else {
      split64High2 = 2147483648;
      split64Low2 = 0;
    }
    return;
  }
  if (isNaN(value)) {
    split64High2 = 2147483647;
    split64Low2 = 4294967295;
    return;
  }
  if (value > FLOAT64_MAX2) {
    split64High2 = (sign << 31 | 2146435072) >>> 0;
    split64Low2 = 0;
    return;
  }
  if (value < FLOAT64_MIN2) {
    const mant2 = value / Math.pow(2, -1074);
    const mantHigh2 = mant2 / TWO_TO_322;
    split64High2 = (sign << 31 | mantHigh2) >>> 0;
    split64Low2 = mant2 >>> 0;
    return;
  }
  const maxDoubleExponent = 1023;
  const minDoubleExponent = -1022;
  let x = value;
  let exp = 0;
  if (x >= 2) {
    while (x >= 2 && exp < maxDoubleExponent) {
      exp++;
      x = x / 2;
    }
  } else {
    while (x < 1 && exp > minDoubleExponent) {
      x = x * 2;
      exp--;
    }
  }
  const mant = value * Math.pow(2, -exp);
  const mantHigh = mant * TWO_TO_202 & 1048575;
  const mantLow = mant * TWO_TO_522 >>> 0;
  split64High2 = (sign << 31 | exp + 1023 << 20 | mantHigh) >>> 0;
  split64Low2 = mantLow;
};
var joinUint642 = function(bitsLow, bitsHigh) {
  return bitsHigh * TWO_TO_322 + (bitsLow >>> 0);
};
var joinInt642 = function(bitsLow, bitsHigh) {
  const sign = bitsHigh & 2147483648;
  if (sign) {
    bitsLow = ~bitsLow + 1 >>> 0;
    bitsHigh = ~bitsHigh >>> 0;
    if (bitsLow == 0) {
      bitsHigh = bitsHigh + 1 >>> 0;
    }
  }
  const result = joinUint642(bitsLow, bitsHigh);
  return sign ? -result : result;
};
var joinZigzag642 = function(bitsLow, bitsHigh) {
  return fromZigzag642(bitsLow, bitsHigh, joinInt642);
};
var joinHash642 = function(bitsLow, bitsHigh) {
  const a = bitsLow >>> 0 & 255;
  const b = bitsLow >>> 8 & 255;
  const c = bitsLow >>> 16 & 255;
  const d = bitsLow >>> 24 & 255;
  const e = bitsHigh >>> 0 & 255;
  const f = bitsHigh >>> 8 & 255;
  const g = bitsHigh >>> 16 & 255;
  const h = bitsHigh >>> 24 & 255;
  return String.fromCharCode(a, b, c, d, e, f, g, h);
};
function joinFloat322(bitsLow) {
  const sign = (bitsLow >> 31) * 2 + 1;
  const exp = bitsLow >>> 23 & 255;
  const mant = bitsLow & 8388607;
  if (exp == 255) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -149) * mant;
  } else {
    return sign * Math.pow(2, exp - 150) * (mant + Math.pow(2, 23));
  }
}
var joinFloat642 = function(bitsLow, bitsHigh) {
  const sign = (bitsHigh >> 31) * 2 + 1;
  const exp = bitsHigh >>> 20 & 2047;
  const mant = TWO_TO_322 * (bitsHigh & 1048575) + bitsLow;
  if (exp == 2047) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }
  if (exp == 0) {
    return sign * Math.pow(2, -1074) * mant;
  } else {
    return sign * Math.pow(2, exp - 1075) * (mant + TWO_TO_522);
  }
};
var joinUnsignedDecimalString2 = function(bitsLow, bitsHigh) {
  if (bitsHigh <= 2097151) {
    return joinUint642(bitsLow, bitsHigh).toString();
  }
  const low = bitsLow & 16777215;
  const mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  const high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    const partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
};
var joinSignedDecimalString2 = function(bitsLow, bitsHigh) {
  const negative = bitsHigh & 2147483648;
  if (negative) {
    bitsLow = ~bitsLow + 1 >>> 0;
    const carry = bitsLow == 0 ? 1 : 0;
    bitsHigh = ~bitsHigh + carry >>> 0;
  }
  const result = joinUnsignedDecimalString2(bitsLow, bitsHigh);
  return negative ? "-" + result : result;
};

// node_modules/protoscript/runtime/decoder.js
var BinaryDecoder2 = class {
  constructor(opt_bytes, opt_start, opt_length) {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
    if (opt_bytes) {
      this.setBlock(opt_bytes, opt_start, opt_length);
    }
  }
  static alloc(opt_bytes, opt_start, opt_length) {
    const newDecoder = BinaryDecoder2.instanceCache_.pop();
    if (newDecoder) {
      if (opt_bytes) {
        newDecoder.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newDecoder;
    } else {
      return new BinaryDecoder2(opt_bytes, opt_start, opt_length);
    }
  }
  free() {
    this.clear();
    if (BinaryDecoder2.instanceCache_.length < 100) {
      BinaryDecoder2.instanceCache_.push(this);
    }
  }
  clone() {
    return BinaryDecoder2.alloc(this.bytes_, this.start_, this.end_ - this.start_);
  }
  clear() {
    this.bytes_ = void 0;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
  }
  getBuffer() {
    return this.bytes_;
  }
  setBlock(data, opt_start, opt_length) {
    this.bytes_ = byteSourceToUint8Array2(data);
    this.start_ = opt_start !== void 0 ? opt_start : 0;
    this.end_ = opt_length !== void 0 ? this.start_ + opt_length : this.bytes_.length;
    this.cursor_ = this.start_;
  }
  getEnd() {
    return this.end_;
  }
  setEnd(end) {
    this.end_ = end;
  }
  reset() {
    this.cursor_ = this.start_;
  }
  getCursor() {
    return this.cursor_;
  }
  setCursor(cursor) {
    this.cursor_ = cursor;
  }
  advance(count) {
    this.cursor_ += count;
    assert2(this.cursor_ <= this.end_);
  }
  atEnd() {
    return this.cursor_ == this.end_;
  }
  pastEnd() {
    return this.cursor_ > this.end_;
  }
  getError() {
    return this.error_ || this.cursor_ < 0 || this.cursor_ > this.end_;
  }
  readSplitVarint64(convert) {
    let temp = 128;
    let lowBits = 0;
    let highBits = 0;
    for (let i = 0; i < 4 && temp >= 128; i++) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << i * 7;
    }
    if (temp >= 128) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 127) << 28;
      highBits |= (temp & 127) >> 4;
    }
    if (temp >= 128) {
      for (let i = 0; i < 5 && temp >= 128; i++) {
        temp = this.bytes_[this.cursor_++];
        highBits |= (temp & 127) << i * 7 + 3;
      }
    }
    if (temp < 128) {
      return convert(lowBits >>> 0, highBits >>> 0);
    }
    fail2("Failed to read varint, encoding is invalid.");
    this.error_ = true;
    return void 0;
  }
  readSplitFixed64(convert) {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    this.cursor_ += 8;
    let lowBits = 0;
    let highBits = 0;
    for (let i = cursor + 7; i >= cursor; i--) {
      lowBits = lowBits << 8 | bytes[i];
      highBits = highBits << 8 | bytes[i + 4];
    }
    return convert(lowBits, highBits);
  }
  skipVarint() {
    while (this.bytes_[this.cursor_] & 128) {
      this.cursor_++;
    }
    this.cursor_++;
  }
  unskipVarint(value) {
    while (value > 128) {
      this.cursor_--;
      value = value >>> 7;
    }
    this.cursor_--;
  }
  readUnsignedVarint32() {
    let temp;
    const bytes = this.bytes_;
    temp = bytes[this.cursor_ + 0];
    let x = temp & 127;
    if (temp < 128) {
      this.cursor_ += 1;
      assert2(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 1];
    x |= (temp & 127) << 7;
    if (temp < 128) {
      this.cursor_ += 2;
      assert2(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 2];
    x |= (temp & 127) << 14;
    if (temp < 128) {
      this.cursor_ += 3;
      assert2(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 3];
    x |= (temp & 127) << 21;
    if (temp < 128) {
      this.cursor_ += 4;
      assert2(this.cursor_ <= this.end_);
      return x;
    }
    temp = bytes[this.cursor_ + 4];
    x |= (temp & 15) << 28;
    if (temp < 128) {
      this.cursor_ += 5;
      assert2(this.cursor_ <= this.end_);
      return x >>> 0;
    }
    this.cursor_ += 5;
    if (bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128) {
      assert2(false);
    }
    assert2(this.cursor_ <= this.end_);
    return x;
  }
  readSignedVarint32() {
    return this.readUnsignedVarint32();
  }
  readUnsignedVarint32String() {
    const value = this.readUnsignedVarint32();
    return value.toString();
  }
  readSignedVarint32String() {
    const value = this.readSignedVarint32();
    return value.toString();
  }
  readZigzagVarint32() {
    const result = this.readUnsignedVarint32();
    return result >>> 1 ^ -(result & 1);
  }
  readUnsignedVarint64() {
    return this.readSplitVarint64(joinUint642);
  }
  readUnsignedVarint64String() {
    return this.readSplitVarint64(joinUnsignedDecimalString2);
  }
  readSignedVarint64() {
    return this.readSplitVarint64(joinInt642);
  }
  readSignedVarint64String() {
    return this.readSplitVarint64(joinSignedDecimalString2);
  }
  readZigzagVarint64() {
    return this.readSplitVarint64(joinZigzag642);
  }
  readSplitZigzagVarint64(convert) {
    return this.readSplitVarint64(function(low, high) {
      return fromZigzag642(low, high, convert);
    });
  }
  readZigzagVarintHash64() {
    return this.readSplitZigzagVarint64(joinHash642);
  }
  readZigzagVarint64String() {
    return this.readSplitZigzagVarint64(joinSignedDecimalString2);
  }
  readUint8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert2(this.cursor_ <= this.end_);
    return a;
  }
  readUint16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert2(this.cursor_ <= this.end_);
    return a << 0 | b << 8;
  }
  readUint32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert2(this.cursor_ <= this.end_);
    return (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
  }
  readUint64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUint642(bitsLow, bitsHigh);
  }
  readUint64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinUnsignedDecimalString2(bitsLow, bitsHigh);
  }
  readInt8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    assert2(this.cursor_ <= this.end_);
    return a << 24 >> 24;
  }
  readInt16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    assert2(this.cursor_ <= this.end_);
    return (a << 0 | b << 8) << 16 >> 16;
  }
  readInt32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    assert2(this.cursor_ <= this.end_);
    return a << 0 | b << 8 | c << 16 | d << 24;
  }
  readInt64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinInt642(bitsLow, bitsHigh);
  }
  readInt64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinSignedDecimalString2(bitsLow, bitsHigh);
  }
  readFloat() {
    const bitsLow = this.readUint32();
    return joinFloat322(bitsLow);
  }
  readDouble() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return joinFloat642(bitsLow, bitsHigh);
  }
  readBool() {
    return !!this.bytes_[this.cursor_++];
  }
  readEnum() {
    return this.readSignedVarint32();
  }
  readString(length) {
    return byteArrayToString2(this.readBytes(length));
  }
  readStringWithLength() {
    const length = this.readUnsignedVarint32();
    return this.readString(length);
  }
  readBytes(length) {
    if (length < 0 || this.cursor_ + length > this.bytes_.length) {
      this.error_ = true;
      fail2("Invalid byte length!");
      return new Uint8Array(0);
    }
    const result = this.bytes_.subarray(this.cursor_, this.cursor_ + length);
    this.cursor_ += length;
    assert2(this.cursor_ <= this.end_);
    return result;
  }
  readVarintHash64() {
    return this.readSplitVarint64(joinHash642);
  }
  readFixedHash64() {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    const a = bytes[cursor + 0];
    const b = bytes[cursor + 1];
    const c = bytes[cursor + 2];
    const d = bytes[cursor + 3];
    const e = bytes[cursor + 4];
    const f = bytes[cursor + 5];
    const g = bytes[cursor + 6];
    const h = bytes[cursor + 7];
    this.cursor_ += 8;
    return String.fromCharCode(a, b, c, d, e, f, g, h);
  }
};
BinaryDecoder2.instanceCache_ = [];

// node_modules/protoscript/runtime/reader.js
var BinaryReader2 = class {
  constructor(opt_bytes = void 0, opt_start = void 0, opt_length = void 0) {
    this.decoder_ = BinaryDecoder2.alloc(opt_bytes, opt_start, opt_length);
    this.fieldCursor_ = this.decoder_.getCursor();
    this.nextField_ = INVALID_FIELD_NUMBER2;
    this.nextWireType_ = WireType2.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
  }
  static alloc(opt_bytes, opt_start, opt_length) {
    const newReader = BinaryReader2.instanceCache_.pop();
    if (newReader) {
      if (opt_bytes) {
        newReader.decoder_.setBlock(opt_bytes, opt_start, opt_length);
      }
      return newReader;
    } else {
      return new BinaryReader2(opt_bytes, opt_start, opt_length);
    }
  }
  free() {
    this.decoder_.clear();
    this.nextField_ = INVALID_FIELD_NUMBER2;
    this.nextWireType_ = WireType2.INVALID;
    this.error_ = false;
    this.readCallbacks_ = {};
    if (BinaryReader2.instanceCache_.length < 100) {
      BinaryReader2.instanceCache_.push(this);
    }
  }
  getFieldCursor() {
    return this.fieldCursor_;
  }
  getCursor() {
    return this.decoder_.getCursor();
  }
  getBuffer() {
    return this.decoder_.getBuffer();
  }
  getFieldNumber() {
    return this.nextField_;
  }
  getWireType() {
    return this.nextWireType_;
  }
  isDelimited() {
    return this.nextWireType_ == WireType2.DELIMITED;
  }
  isEndGroup() {
    return this.nextWireType_ == WireType2.END_GROUP;
  }
  getError() {
    return this.error_ || this.decoder_.getError();
  }
  setBlock(bytes, start, length) {
    this.decoder_.setBlock(bytes, start, length);
    this.nextField_ = INVALID_FIELD_NUMBER2;
    this.nextWireType_ = WireType2.INVALID;
  }
  reset() {
    this.decoder_.reset();
    this.nextField_ = INVALID_FIELD_NUMBER2;
    this.nextWireType_ = WireType2.INVALID;
  }
  advance(count) {
    this.decoder_.advance(count);
  }
  nextField() {
    if (this.decoder_.atEnd()) {
      return false;
    }
    if (this.getError()) {
      fail2("Decoder hit an error");
      return false;
    }
    this.fieldCursor_ = this.decoder_.getCursor();
    const header = this.decoder_.readUnsignedVarint32();
    const nextField = header >>> 3;
    const nextWireType = header & 7;
    if (nextWireType != WireType2.VARINT && nextWireType != WireType2.FIXED32 && nextWireType != WireType2.FIXED64 && nextWireType != WireType2.DELIMITED && nextWireType != WireType2.START_GROUP && nextWireType != WireType2.END_GROUP) {
      fail2(`Invalid wire type: ${nextWireType} (at position ${this.fieldCursor_})`);
      this.error_ = true;
      return false;
    }
    this.nextField_ = nextField;
    this.nextWireType_ = nextWireType;
    return true;
  }
  unskipHeader() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }
  skipMatchingFields() {
    const field = this.nextField_;
    this.unskipHeader();
    while (this.nextField() && this.getFieldNumber() == field) {
      this.skipField();
    }
    if (!this.decoder_.atEnd()) {
      this.unskipHeader();
    }
  }
  skipVarintField() {
    if (this.nextWireType_ != WireType2.VARINT) {
      fail2("Invalid wire type for skipVarintField");
      this.skipField();
      return;
    }
    this.decoder_.skipVarint();
  }
  skipDelimitedField() {
    if (this.nextWireType_ != WireType2.DELIMITED) {
      fail2("Invalid wire type for skipDelimitedField");
      this.skipField();
      return;
    }
    const length = this.decoder_.readUnsignedVarint32();
    this.decoder_.advance(length);
  }
  skipFixed32Field() {
    if (this.nextWireType_ != WireType2.FIXED32) {
      fail2("Invalid wire type for skipFixed32Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(4);
  }
  skipFixed64Field() {
    if (this.nextWireType_ != WireType2.FIXED64) {
      fail2("Invalid wire type for skipFixed64Field");
      this.skipField();
      return;
    }
    this.decoder_.advance(8);
  }
  skipGroup() {
    const previousField = this.nextField_;
    while (true) {
      if (!this.nextField()) {
        fail2("Unmatched start-group tag: stream EOF");
        this.error_ = true;
        return;
      }
      if (this.nextWireType_ == WireType2.END_GROUP) {
        if (this.nextField_ != previousField) {
          fail2("Unmatched end-group tag");
          this.error_ = true;
          return;
        }
        return;
      }
      this.skipField();
    }
  }
  skipField() {
    switch (this.nextWireType_) {
      case WireType2.VARINT:
        this.skipVarintField();
        break;
      case WireType2.FIXED64:
        this.skipFixed64Field();
        break;
      case WireType2.DELIMITED:
        this.skipDelimitedField();
        break;
      case WireType2.FIXED32:
        this.skipFixed32Field();
        break;
      case WireType2.START_GROUP:
        this.skipGroup();
        break;
      default:
        fail2("Invalid wire encoding for field.");
    }
  }
  registerReadCallback(callbackName, callback) {
    assert2(!this.readCallbacks_[callbackName]);
    this.readCallbacks_[callbackName] = callback;
  }
  runReadCallback(callbackName) {
    const callback = this.readCallbacks_[callbackName];
    assert2(!!callback);
    return callback(this);
  }
  readAny(fieldType) {
    this.nextWireType_ = FieldTypeToWireType2(fieldType);
    switch (fieldType) {
      case FieldType2.DOUBLE:
        return this.readDouble();
      case FieldType2.FLOAT:
        return this.readFloat();
      case FieldType2.INT64:
        return this.readInt64();
      case FieldType2.UINT64:
        return this.readUint64();
      case FieldType2.INT32:
        return this.readInt32();
      case FieldType2.FIXED64:
        return this.readFixed64();
      case FieldType2.FIXED32:
        return this.readFixed32();
      case FieldType2.BOOL:
        return this.readBool();
      case FieldType2.STRING:
        return this.readString();
      case FieldType2.GROUP:
        fail2("Group field type not supported in readAny()");
        break;
      case FieldType2.MESSAGE:
        fail2("Message field type not supported in readAny()");
        break;
      case FieldType2.BYTES:
        return this.readBytes();
      case FieldType2.UINT32:
        return this.readUint32();
      case FieldType2.ENUM:
        return this.readEnum();
      case FieldType2.SFIXED32:
        return this.readSfixed32();
      case FieldType2.SFIXED64:
        return this.readSfixed64();
      case FieldType2.SINT32:
        return this.readSint32();
      case FieldType2.SINT64:
        return this.readSint64();
      case FieldType2.FHASH64:
        return this.readFixedHash64();
      case FieldType2.VHASH64:
        return this.readVarintHash64();
      default:
        fail2("Invalid field type in readAny()");
    }
    return 0;
  }
  readMessage(message, reader) {
    assert2(this.nextWireType_ == WireType2.DELIMITED);
    const oldEnd = this.decoder_.getEnd();
    const length = this.decoder_.readUnsignedVarint32();
    const newEnd = this.decoder_.getCursor() + length;
    this.decoder_.setEnd(newEnd);
    reader(message, this);
    this.decoder_.setCursor(newEnd);
    this.decoder_.setEnd(oldEnd);
  }
  readGroup(field, message, reader) {
    assert2(this.nextWireType_ == WireType2.START_GROUP);
    assert2(this.nextField_ == field);
    reader(message, this);
    if (!this.error_ && this.nextWireType_ != WireType2.END_GROUP) {
      fail2("Group submessage did not end with an END_GROUP tag");
      this.error_ = true;
    }
  }
  getFieldDecoder() {
    assert2(this.nextWireType_ == WireType2.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const start = this.decoder_.getCursor();
    const end = start + length;
    const innerDecoder = BinaryDecoder2.alloc(this.decoder_.getBuffer(), start, length);
    this.decoder_.setCursor(end);
    return innerDecoder;
  }
  readInt32() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSignedVarint32();
  }
  readInt32String() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSignedVarint32String();
  }
  readInt64() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  readInt64String() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSignedVarint64String();
  }
  readUint32() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readUnsignedVarint32();
  }
  readUint32String() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readUnsignedVarint32String();
  }
  readUint64() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readUnsignedVarint64();
  }
  readUint64String() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readUnsignedVarint64String();
  }
  readSint32() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readZigzagVarint32();
  }
  readSint64() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readZigzagVarint64();
  }
  readSint64String() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readZigzagVarint64String();
  }
  readFixed32() {
    assert2(this.nextWireType_ == WireType2.FIXED32);
    return this.decoder_.readUint32();
  }
  readFixed64() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readUint64();
  }
  readFixed64String() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readUint64String();
  }
  readSfixed32() {
    assert2(this.nextWireType_ == WireType2.FIXED32);
    return this.decoder_.readInt32();
  }
  readSfixed32String() {
    assert2(this.nextWireType_ == WireType2.FIXED32);
    return this.decoder_.readInt32().toString();
  }
  readSfixed64() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readInt64();
  }
  readSfixed64String() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readInt64String();
  }
  readFloat() {
    assert2(this.nextWireType_ == WireType2.FIXED32);
    return this.decoder_.readFloat();
  }
  readDouble() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readDouble();
  }
  readBool() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return !!this.decoder_.readUnsignedVarint32();
  }
  readEnum() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSignedVarint64();
  }
  readString() {
    assert2(this.nextWireType_ == WireType2.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(length);
  }
  readBytes() {
    assert2(this.nextWireType_ == WireType2.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(length);
  }
  readVarintHash64() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readVarintHash64();
  }
  readSintHash64() {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readZigzagVarintHash64();
  }
  readSplitVarint64(convert) {
    assert2(this.nextWireType_ == WireType2.VARINT);
    return this.decoder_.readSplitVarint64(convert);
  }
  readFixedHash64() {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readFixedHash64();
  }
  readSplitFixed64(convert) {
    assert2(this.nextWireType_ == WireType2.FIXED64);
    return this.decoder_.readSplitFixed64(convert);
  }
  readPackedField_(decodeMethod) {
    assert2(this.nextWireType_ == WireType2.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    const end = this.decoder_.getCursor() + length;
    const result = [];
    while (this.decoder_.getCursor() < end) {
      result.push(decodeMethod.call(this.decoder_));
    }
    return result;
  }
  readPackedInt32() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }
  readPackedInt32String() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }
  readPackedInt64() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }
  readPackedInt64String() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }
  readPackedUint32() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }
  readPackedUint32String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }
  readPackedUint64() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }
  readPackedUint64String() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }
  readPackedSint32() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }
  readPackedSint64() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }
  readPackedSint64String() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }
  readPackedFixed32() {
    return this.readPackedField_(this.decoder_.readUint32);
  }
  readPackedFixed64() {
    return this.readPackedField_(this.decoder_.readUint64);
  }
  readPackedFixed64String() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }
  readPackedSfixed32() {
    return this.readPackedField_(this.decoder_.readInt32);
  }
  readPackedSfixed64() {
    return this.readPackedField_(this.decoder_.readInt64);
  }
  readPackedSfixed64String() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }
  readPackedFloat() {
    return this.readPackedField_(this.decoder_.readFloat);
  }
  readPackedDouble() {
    return this.readPackedField_(this.decoder_.readDouble);
  }
  readPackedBool() {
    return this.readPackedField_(this.decoder_.readBool);
  }
  readPackedEnum() {
    return this.readPackedField_(this.decoder_.readEnum);
  }
  readPackedVarintHash64() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }
  readPackedFixedHash64() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }
};
BinaryReader2.instanceCache_ = [];

// node_modules/protoscript/runtime/encoder.js
var BinaryEncoder2 = class {
  constructor() {
    this.buffer_ = [];
  }
  length() {
    return this.buffer_.length;
  }
  end() {
    const buffer = this.buffer_;
    this.buffer_ = [];
    return buffer;
  }
  writeSplitVarint64(lowBits, highBits) {
    assert2(lowBits == Math.floor(lowBits));
    assert2(highBits == Math.floor(highBits));
    assert2(lowBits >= 0 && lowBits < TWO_TO_322);
    assert2(highBits >= 0 && highBits < TWO_TO_322);
    while (highBits > 0 || lowBits > 127) {
      this.buffer_.push(lowBits & 127 | 128);
      lowBits = (lowBits >>> 7 | highBits << 25) >>> 0;
      highBits = highBits >>> 7;
    }
    this.buffer_.push(lowBits);
  }
  writeSplitFixed64(lowBits, highBits) {
    assert2(lowBits == Math.floor(lowBits));
    assert2(highBits == Math.floor(highBits));
    assert2(lowBits >= 0 && lowBits < TWO_TO_322);
    assert2(highBits >= 0 && highBits < TWO_TO_322);
    this.writeUint32(lowBits);
    this.writeUint32(highBits);
  }
  writeUnsignedVarint32(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < TWO_TO_322);
    while (value > 127) {
      this.buffer_.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buffer_.push(value);
  }
  writeSignedVarint32(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    if (value >= 0) {
      this.writeUnsignedVarint32(value);
      return;
    }
    for (let i = 0; i < 9; i++) {
      this.buffer_.push(value & 127 | 128);
      value = value >> 7;
    }
    this.buffer_.push(1);
  }
  writeUnsignedVarint64(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < TWO_TO_642);
    splitInt642(value);
    this.writeSplitVarint64(split64Low2, split64High2);
  }
  writeSignedVarint64(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    splitInt642(value);
    this.writeSplitVarint64(split64Low2, split64High2);
  }
  writeZigzagVarint32(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeUnsignedVarint32((value << 1 ^ value >> 31) >>> 0);
  }
  writeZigzagVarint64(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    splitZigzag642(value);
    this.writeSplitVarint64(split64Low2, split64High2);
  }
  writeZigzagVarint64String(value) {
    this.writeZigzagVarintHash64(decimalStringToHash642(value));
  }
  writeZigzagVarintHash64(hash) {
    splitHash642(hash);
    toZigzag642(split64Low2, split64High2, (lo, hi) => {
      this.writeSplitVarint64(lo >>> 0, hi >>> 0);
    });
  }
  writeUint8(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < 256);
    this.buffer_.push(value >>> 0 & 255);
  }
  writeUint16(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < 65536);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  writeUint32(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < TWO_TO_322);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  writeUint64(value) {
    assert2(value == Math.floor(value));
    assert2(value >= 0 && value < TWO_TO_642);
    splitUint642(value);
    this.writeUint32(split64Low2);
    this.writeUint32(split64High2);
  }
  writeInt8(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -128 && value < 128);
    this.buffer_.push(value >>> 0 & 255);
  }
  writeInt16(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -32768 && value < 32768);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
  }
  writeInt32(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.buffer_.push(value >>> 0 & 255);
    this.buffer_.push(value >>> 8 & 255);
    this.buffer_.push(value >>> 16 & 255);
    this.buffer_.push(value >>> 24 & 255);
  }
  writeInt64(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    splitInt642(value);
    this.writeSplitFixed64(split64Low2, split64High2);
  }
  writeInt64String(value) {
    assert2(value == Math.floor(value));
    assert2(+value >= -TWO_TO_632 && +value < TWO_TO_632);
    splitHash642(decimalStringToHash642(value));
    this.writeSplitFixed64(split64Low2, split64High2);
  }
  writeFloat(value) {
    assert2(value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT32_MAX2 && value <= FLOAT32_MAX2);
    splitFloat322(value);
    this.writeUint32(split64Low2);
  }
  writeDouble(value) {
    assert2(value === Infinity || value === -Infinity || isNaN(value) || value >= -FLOAT64_MAX2 && value <= FLOAT64_MAX2);
    splitFloat642(value);
    this.writeUint32(split64Low2);
    this.writeUint32(split64High2);
  }
  writeBool(value) {
    assert2(typeof value === "boolean" || typeof value === "number");
    this.buffer_.push(value ? 1 : 0);
  }
  writeEnum(value) {
    assert2(value == Math.floor(value));
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeSignedVarint32(value);
  }
  writeBytes(bytes) {
    this.buffer_.push(...bytes);
  }
  writeVarintHash64(hash) {
    splitHash642(hash);
    this.writeSplitVarint64(split64Low2, split64High2);
  }
  writeFixedHash64(hash) {
    splitHash642(hash);
    this.writeUint32(split64Low2);
    this.writeUint32(split64High2);
  }
  writeString(value) {
    const oldLength = this.buffer_.length;
    const buffer = stringToUint8Array2(value);
    buffer.forEach((val) => this.buffer_.push(val));
    const length = this.buffer_.length - oldLength;
    return length;
  }
};

// node_modules/protoscript/runtime/arith.js
var UInt642 = class {
  constructor(bigint, lo, hi) {
    this.bigint = bigint;
    this.lo = lo;
    this.hi = hi;
  }
  toString() {
    return this.bigint.toString();
  }
  static fromString(s) {
    const bigint = BigInt.asUintN(64, BigInt(s));
    const lo = Number(BigInt.asUintN(32, bigint));
    const hi = Number(bigint >> BigInt(32));
    return new UInt642(bigint, lo, hi);
  }
};
var Int642 = class extends UInt642 {
  static fromString(s) {
    const bigint = BigInt.asIntN(64, BigInt(s));
    const { lo, hi } = UInt642.fromString(s);
    return new Int642(bigint, lo, hi);
  }
};

// node_modules/protoscript/runtime/writer.js
var BinaryWriter2 = class {
  constructor() {
    this.blocks_ = [];
    this.totalLength_ = 0;
    this.encoder_ = new BinaryEncoder2();
  }
  appendUint8Array_(arr) {
    const temp = this.encoder_.end();
    this.blocks_.push(temp);
    this.blocks_.push(arr);
    this.totalLength_ += temp.length + arr.length;
  }
  beginDelimited_(field) {
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    const bookmark = this.encoder_.end();
    this.blocks_.push(bookmark);
    this.totalLength_ += bookmark.length;
    bookmark.push(this.totalLength_);
    return bookmark;
  }
  endDelimited_(bookmark) {
    const oldLength = bookmark.pop() ?? 0;
    let messageLength = this.totalLength_ + this.encoder_.length() - oldLength;
    assert2(messageLength >= 0);
    while (messageLength > 127) {
      bookmark.push(messageLength & 127 | 128);
      messageLength = messageLength >>> 7;
      this.totalLength_++;
    }
    bookmark.push(messageLength);
    this.totalLength_++;
  }
  writeSerializedMessage(bytes, start, end) {
    this.appendUint8Array_(bytes.subarray(start, end));
  }
  maybeWriteSerializedMessage(bytes, start, end) {
    if (bytes != null && start != null && end != null) {
      this.writeSerializedMessage(bytes, start, end);
    }
  }
  reset() {
    this.blocks_ = [];
    this.encoder_.end();
    this.totalLength_ = 0;
  }
  getResultBuffer() {
    const flat = new Uint8Array(this.totalLength_ + this.encoder_.length());
    const blocks = this.blocks_;
    const blockCount = blocks.length;
    let offset = 0;
    for (let i = 0; i < blockCount; i++) {
      const block = blocks[i];
      flat.set(block, offset);
      offset += block.length;
    }
    const tail = this.encoder_.end();
    flat.set(tail, offset);
    offset += tail.length;
    assert2(offset == flat.length);
    this.blocks_ = [flat];
    return flat;
  }
  writeFieldHeader_(field, wireType) {
    assert2(field >= 1 && field == Math.floor(field));
    const x = field * 8 + wireType;
    this.encoder_.writeUnsignedVarint32(x);
  }
  writeAny(fieldType, field, value) {
    switch (fieldType) {
      case FieldType2.DOUBLE:
        this.writeDouble(field, value);
        return;
      case FieldType2.FLOAT:
        this.writeFloat(field, value);
        return;
      case FieldType2.INT64:
        this.writeInt64(field, value);
        return;
      case FieldType2.UINT64:
        this.writeUint64(field, value);
        return;
      case FieldType2.INT32:
        this.writeInt32(field, value);
        return;
      case FieldType2.FIXED64:
        this.writeFixed64(field, value);
        return;
      case FieldType2.FIXED32:
        this.writeFixed32(field, value);
        return;
      case FieldType2.BOOL:
        this.writeBool(field, value);
        return;
      case FieldType2.STRING:
        this.writeString(field, value);
        return;
      case FieldType2.GROUP:
        fail2("Group field type not supported in writeAny()");
        return;
      case FieldType2.MESSAGE:
        fail2("Message field type not supported in writeAny()");
        return;
      case FieldType2.BYTES:
        this.writeBytes(field, value);
        return;
      case FieldType2.UINT32:
        this.writeUint32(field, value);
        return;
      case FieldType2.ENUM:
        this.writeEnum(field, value);
        return;
      case FieldType2.SFIXED32:
        this.writeSfixed32(field, value);
        return;
      case FieldType2.SFIXED64:
        this.writeSfixed64(field, value);
        return;
      case FieldType2.SINT32:
        this.writeSint32(field, value);
        return;
      case FieldType2.SINT64:
        this.writeSint64(field, value);
        return;
      case FieldType2.FHASH64:
        this.writeFixedHash64(field, value);
        return;
      case FieldType2.VHASH64:
        this.writeVarintHash64(field, value);
        return;
      default:
        fail2("Invalid field type in writeAny()");
        return;
    }
  }
  writeUnsignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeUnsignedVarint32(value);
  }
  writeSignedVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  writeUnsignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeUnsignedVarint64(value);
  }
  writeSignedVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSignedVarint64(value);
  }
  writeZigzagVarint32_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeZigzagVarint32(value);
  }
  writeZigzagVarint64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeZigzagVarint64(value);
  }
  writeZigzagVarint64String_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeZigzagVarint64String(value);
  }
  writeZigzagVarintHash64_(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeZigzagVarintHash64(value);
  }
  writeInt32(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeSignedVarint32_(field, value);
  }
  writeInt32String(field, value) {
    if (value == null)
      return;
    const intValue = parseInt(value, 10);
    assert2(intValue >= -TWO_TO_312 && intValue < TWO_TO_312);
    this.writeSignedVarint32_(field, intValue);
  }
  writeInt64(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    this.writeSignedVarint64_(field, value);
  }
  writeInt64String(field, value) {
    if (value == null)
      return;
    const num = Int642.fromString(value);
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  writeUint32(field, value) {
    if (value == null)
      return;
    assert2(value >= 0 && value < TWO_TO_322);
    this.writeUnsignedVarint32_(field, value);
  }
  writeUint32String(field, value) {
    if (value == null)
      return;
    const intValue = parseInt(value, 10);
    assert2(intValue >= 0 && intValue < TWO_TO_322);
    this.writeUnsignedVarint32_(field, intValue);
  }
  writeUint64(field, value) {
    if (value == null)
      return;
    assert2(value >= 0 && value < TWO_TO_642);
    this.writeUnsignedVarint64_(field, value);
  }
  writeUint64String(field, value) {
    if (value == null)
      return;
    const num = UInt642.fromString(value);
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }
  writeSint32(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeZigzagVarint32_(field, value);
  }
  writeSint64(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    this.writeZigzagVarint64_(field, value);
  }
  writeSintHash64(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarintHash64_(field, value);
  }
  writeSint64String(field, value) {
    if (value == null)
      return;
    this.writeZigzagVarint64String_(field, value);
  }
  writeFixed32(field, value) {
    if (value == null)
      return;
    assert2(value >= 0 && value < TWO_TO_322);
    this.writeFieldHeader_(field, WireType2.FIXED32);
    this.encoder_.writeUint32(value);
  }
  writeFixed64(field, value) {
    if (value == null)
      return;
    assert2(value >= 0 && value < TWO_TO_642);
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeUint64(value);
  }
  writeFixed64String(field, value) {
    if (value == null)
      return;
    const num = UInt642.fromString(value);
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  writeSfixed32(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeFieldHeader_(field, WireType2.FIXED32);
    this.encoder_.writeInt32(value);
  }
  writeSfixed64(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_632 && value < TWO_TO_632);
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeInt64(value);
  }
  writeSfixed64String(field, value) {
    if (value == null)
      return;
    const num = Int642.fromString(value);
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }
  writeFloat(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.FIXED32);
    this.encoder_.writeFloat(value);
  }
  writeDouble(field, value) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeDouble(value);
  }
  writeBool(field, value) {
    if (value == null)
      return;
    assert2(typeof value === "boolean" || typeof value === "number");
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeBool(value);
  }
  writeEnum(field, value) {
    if (value == null)
      return;
    assert2(value >= -TWO_TO_312 && value < TWO_TO_312);
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }
  writeString(field, value) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    this.encoder_.writeString(value);
    this.endDelimited_(bookmark);
  }
  writeBytes(field, value) {
    if (value == null)
      return;
    const bytes = byteSourceToUint8Array2(value);
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(bytes.length);
    this.appendUint8Array_(bytes);
  }
  writeMessage(field, value, writerCallback) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
  }
  writeMessageSet(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(1, WireType2.START_GROUP);
    this.writeFieldHeader_(2, WireType2.VARINT);
    this.encoder_.writeSignedVarint32(field);
    const bookmark = this.beginDelimited_(3);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
    this.writeFieldHeader_(1, WireType2.END_GROUP);
  }
  writeGroup(field, value, writerCallback) {
    if (value == null)
      return;
    this.writeFieldHeader_(field, WireType2.START_GROUP);
    writerCallback(value, this);
    this.writeFieldHeader_(field, WireType2.END_GROUP);
  }
  writeFixedHash64(field, value) {
    if (value == null)
      return;
    assert2(value.length == 8);
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeFixedHash64(value);
  }
  writeVarintHash64(field, value) {
    if (value == null)
      return;
    assert2(value.length == 8);
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeVarintHash64(value);
  }
  writeSplitFixed64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType2.FIXED64);
    this.encoder_.writeSplitFixed64(lowBits, highBits);
  }
  writeSplitVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType2.VARINT);
    this.encoder_.writeSplitVarint64(lowBits, highBits);
  }
  writeSplitZigzagVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType2.VARINT);
    const encoder3 = this.encoder_;
    toZigzag642(lowBits, highBits, function(lowBits2, highBits2) {
      encoder3.writeSplitVarint64(lowBits2 >>> 0, highBits2 >>> 0);
    });
  }
  writeRepeatedInt32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint32_(field, value[i]);
    }
  }
  writeRepeatedInt32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt32String(field, value[i]);
    }
  }
  writeRepeatedInt64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint64_(field, value[i]);
    }
  }
  writeRepeatedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitFixed64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitZigzagVarint64(field, lo(value[i]), hi(value[i]));
    }
  }
  writeRepeatedInt64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt64String(field, value[i]);
    }
  }
  writeRepeatedUint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint32_(field, value[i]);
    }
  }
  writeRepeatedUint32String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint32String(field, value[i]);
    }
  }
  writeRepeatedUint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint64_(field, value[i]);
    }
  }
  writeRepeatedUint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint64String(field, value[i]);
    }
  }
  writeRepeatedSint32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint32_(field, value[i]);
    }
  }
  writeRepeatedSint64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64_(field, value[i]);
    }
  }
  writeRepeatedSint64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64String_(field, value[i]);
    }
  }
  writeRepeatedSintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarintHash64_(field, value[i]);
    }
  }
  writeRepeatedFixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed32(field, value[i]);
    }
  }
  writeRepeatedFixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64(field, value[i]);
    }
  }
  writeRepeatedFixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64String(field, value[i]);
    }
  }
  writeRepeatedSfixed32(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed32(field, value[i]);
    }
  }
  writeRepeatedSfixed64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64(field, value[i]);
    }
  }
  writeRepeatedSfixed64String(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64String(field, value[i]);
    }
  }
  writeRepeatedFloat(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFloat(field, value[i]);
    }
  }
  writeRepeatedDouble(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeDouble(field, value[i]);
    }
  }
  writeRepeatedBool(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBool(field, value[i]);
    }
  }
  writeRepeatedEnum(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeEnum(field, value[i]);
    }
  }
  writeRepeatedString(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeString(field, value[i]);
    }
  }
  writeRepeatedBytes(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeBytes(field, value[i]);
    }
  }
  writeRepeatedMessage(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      const bookmark = this.beginDelimited_(field);
      writerCallback(value[i], this);
      this.endDelimited_(bookmark);
    }
  }
  writeRepeatedGroup(field, value, writerCallback) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFieldHeader_(field, WireType2.START_GROUP);
      writerCallback(value[i], this);
      this.writeFieldHeader_(field, WireType2.END_GROUP);
    }
  }
  writeRepeatedFixedHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixedHash64(field, value[i]);
    }
  }
  writeRepeatedVarintHash64(field, value) {
    if (value == null)
      return;
    for (let i = 0; i < value.length; i++) {
      this.writeVarintHash64(field, value[i]);
    }
  }
  writePackedInt32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt32String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitFixed64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitFixed64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitVarint64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null)
      return;
    const bookmark = this.beginDelimited_(field);
    const encoder3 = this.encoder_;
    for (let i = 0; i < value.length; i++) {
      toZigzag642(lo(value[i]), hi(value[i]), function(bitsLow, bitsHigh) {
        encoder3.writeSplitVarint64(bitsLow >>> 0, bitsHigh >>> 0);
      });
    }
    this.endDelimited_(bookmark);
  }
  writePackedInt64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = Int642.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint32String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(parseInt(value[i], 10));
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedUint64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = UInt642.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint32(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedSint64String(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(decimalStringToHash642(value[i]));
    }
    this.endDelimited_(bookmark);
  }
  writePackedSintHash64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedFixed32(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint32(value[i]);
    }
  }
  writePackedFixed64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint64(value[i]);
    }
  }
  writePackedFixed64String(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      const num = UInt642.fromString(value[i]);
      this.encoder_.writeSplitFixed64(num.lo, num.hi);
    }
  }
  writePackedSfixed32(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt32(value[i]);
    }
  }
  writePackedSfixed64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64(value[i]);
    }
  }
  writePackedSfixed64String(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64String(value[i]);
    }
  }
  writePackedFloat(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFloat(value[i]);
    }
  }
  writePackedDouble(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeDouble(value[i]);
    }
  }
  writePackedBool(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeBool(value[i]);
    }
  }
  writePackedEnum(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeEnum(value[i]);
    }
    this.endDelimited_(bookmark);
  }
  writePackedFixedHash64(field, value) {
    if (value == null || !value.length)
      return;
    this.writeFieldHeader_(field, WireType2.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFixedHash64(value[i]);
    }
  }
  writePackedVarintHash64(field, value) {
    if (value == null || !value.length)
      return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeVarintHash64(value[i]);
    }
    this.endDelimited_(bookmark);
  }
};

// node_modules/protoscript/runtime/json.js
function encodeBase64Bytes2(bytes) {
  return btoa(byteArrayToString2(bytes));
}
function decodeBase64Bytes2(bytes) {
  return stringToUint8Array2(atob(bytes));
}

// node_modules/protoscript/runtime/well-known-types/any.pb.js
var Any = {
  encode: function(msg) {
    return Any._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Any._readMessage(Any.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      typeUrl: "",
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var AnyJSON = {
  encode: function(msg) {
    return JSON.stringify(AnyJSON._writeMessage(msg));
  },
  decode: function(json) {
    return AnyJSON._readMessage(AnyJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      typeUrl: "",
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.value?.length) {
      json["value"] = encodeBase64Bytes2(msg.value);
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _typeUrl = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json["value"];
    if (_value) {
      msg.value = decodeBase64Bytes2(_value);
    }
    return msg;
  }
};

// node_modules/protoscript/runtime/well-known-types/source_context.pb.js
var SourceContext = {
  encode: function(msg) {
    return SourceContext._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return SourceContext._readMessage(SourceContext.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      fileName: ""
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SourceContextJSON = {
  encode: function(msg) {
    return JSON.stringify(SourceContextJSON._writeMessage(msg));
  },
  decode: function(json) {
    return SourceContextJSON._readMessage(SourceContextJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      fileName: ""
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.fileName) {
      json["fileName"] = msg.fileName;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _fileName = json["fileName"] ?? json["file_name"];
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  }
};

// node_modules/protoscript/runtime/well-known-types/type.pb.js
var Syntax = {
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      default: {
        return i;
      }
    }
  }
};
var Option = {
  encode: function(msg) {
    return Option._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Option._readMessage(Option.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      value: Any.initialize()
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SyntaxJSON = {
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      default: {
        return i;
      }
    }
  }
};
var OptionJSON = {
  encode: function(msg) {
    return JSON.stringify(OptionJSON._writeMessage(msg));
  },
  decode: function(json) {
    return OptionJSON._readMessage(OptionJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      value: Any.initialize()
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.value) {
      const value = AnyJSON._writeMessage(msg.value);
      if (Object.keys(value).length > 0) {
        json["value"] = value;
      }
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _value = json["value"];
    if (_value) {
      const m = Any.initialize();
      AnyJSON._readMessage(m, _value);
      msg.value = m;
    }
    return msg;
  }
};

// src/runtime/well-known-types/any.pb.ts
var Any2 = {
  encode: function(msg) {
    return Any2._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Any2._readMessage(Any2.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      typeUrl: "",
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var AnyJSON2 = {
  encode: function(msg) {
    return JSON.stringify(AnyJSON2._writeMessage(msg));
  },
  decode: function(json) {
    return AnyJSON2._readMessage(AnyJSON2.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      typeUrl: "",
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.value?.length) {
      json["value"] = encodeBase64Bytes2(msg.value);
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _typeUrl = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json["value"];
    if (_value) {
      msg.value = decodeBase64Bytes2(_value);
    }
    return msg;
  }
};

// src/runtime/well-known-types/api.pb.ts
var Api = {
  encode: function(msg) {
    return Api._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Api._readMessage(Api.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      methods: [],
      options: [],
      version: "",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: Syntax._fromInt(0)
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
    }
    if (msg.syntax && Syntax._toInt(msg.syntax)) {
      writer.writeEnum(7, Syntax._toInt(msg.syntax));
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Method = {
  encode: function(msg) {
    return Method._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Method._readMessage(Method.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      requestTypeUrl: "",
      requestStreaming: false,
      responseTypeUrl: "",
      responseStreaming: false,
      options: [],
      syntax: Syntax._fromInt(0)
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(6, msg.options, Option._writeMessage);
    }
    if (msg.syntax && Syntax._toInt(msg.syntax)) {
      writer.writeEnum(7, Syntax._toInt(msg.syntax));
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Mixin = {
  encode: function(msg) {
    return Mixin._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Mixin._readMessage(Mixin.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      root: ""
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var ApiJSON = {
  encode: function(msg) {
    return JSON.stringify(ApiJSON._writeMessage(msg));
  },
  decode: function(json) {
    return ApiJSON._readMessage(ApiJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      methods: [],
      options: [],
      version: "",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: Syntax._fromInt(0)
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.methods?.length) {
      json["methods"] = msg.methods.map(MethodJSON._writeMessage);
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    if (msg.version) {
      json["version"] = msg.version;
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json["sourceContext"] = sourceContext;
      }
    }
    if (msg.mixins?.length) {
      json["mixins"] = msg.mixins.map(MixinJSON._writeMessage);
    }
    if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _methods = json["methods"];
    if (_methods) {
      for (const item of _methods) {
        const m = Method.initialize();
        MethodJSON._readMessage(m, item);
        msg.methods.push(m);
      }
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _version = json["version"];
    if (_version) {
      msg.version = _version;
    }
    const _sourceContext = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContextJSON._readMessage(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _mixins = json["mixins"];
    if (_mixins) {
      for (const item of _mixins) {
        const m = Mixin.initialize();
        MixinJSON._readMessage(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  }
};
var MethodJSON = {
  encode: function(msg) {
    return JSON.stringify(MethodJSON._writeMessage(msg));
  },
  decode: function(json) {
    return MethodJSON._readMessage(MethodJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      requestTypeUrl: "",
      requestStreaming: false,
      responseTypeUrl: "",
      responseStreaming: false,
      options: [],
      syntax: Syntax._fromInt(0)
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.requestTypeUrl) {
      json["requestTypeUrl"] = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json["requestStreaming"] = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json["responseTypeUrl"] = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json["responseStreaming"] = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _requestTypeUrl = json["requestTypeUrl"] ?? json["request_type_url"];
    if (_requestTypeUrl) {
      msg.requestTypeUrl = _requestTypeUrl;
    }
    const _requestStreaming = json["requestStreaming"] ?? json["request_streaming"];
    if (_requestStreaming) {
      msg.requestStreaming = _requestStreaming;
    }
    const _responseTypeUrl = json["responseTypeUrl"] ?? json["response_type_url"];
    if (_responseTypeUrl) {
      msg.responseTypeUrl = _responseTypeUrl;
    }
    const _responseStreaming = json["responseStreaming"] ?? json["response_streaming"];
    if (_responseStreaming) {
      msg.responseStreaming = _responseStreaming;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  }
};
var MixinJSON = {
  encode: function(msg) {
    return JSON.stringify(MixinJSON._writeMessage(msg));
  },
  decode: function(json) {
    return MixinJSON._readMessage(MixinJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      root: ""
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.root) {
      json["root"] = msg.root;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _root = json["root"];
    if (_root) {
      msg.root = _root;
    }
    return msg;
  }
};

// src/runtime/well-known-types/duration.pb.ts
var Duration = {
  encode: function(msg) {
    return Duration._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Duration._readMessage(
      Duration.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      seconds: 0n,
      nanos: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var DurationJSON = {
  encode: function(msg) {
    return JSON.stringify(DurationJSON._writeMessage(msg));
  },
  decode: function(json) {
    return DurationJSON._readMessage(
      DurationJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      seconds: 0n,
      nanos: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.seconds) {
      json["seconds"] = msg.seconds.toString();
    }
    if (msg.nanos) {
      json["nanos"] = msg.nanos;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _seconds = json["seconds"];
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json["nanos"];
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  }
};

// src/runtime/well-known-types/empty.pb.ts
var Empty = {
  encode: function(_msg) {
    return new Uint8Array();
  },
  decode: function(_bytes) {
    return {};
  },
  initialize: function() {
    return {};
  },
  _writeMessage: function(_msg, writer) {
    return writer;
  },
  _readMessage: function(_msg, _reader) {
    return _msg;
  }
};
var EmptyJSON = {
  encode: function(_msg) {
    return "{}";
  },
  decode: function(_json) {
    return {};
  },
  initialize: function() {
    return {};
  },
  _writeMessage: function(_msg) {
    return {};
  },
  _readMessage: function(msg, _json) {
    return msg;
  }
};

// src/runtime/well-known-types/field_mask.pb.ts
var FieldMask = {
  encode: function(msg) {
    return FieldMask._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      paths: []
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var FieldMaskJSON = {
  encode: function(msg) {
    return JSON.stringify(FieldMaskJSON._writeMessage(msg));
  },
  decode: function(json) {
    return FieldMaskJSON._readMessage(
      FieldMaskJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      paths: []
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.paths?.length) {
      json["paths"] = msg.paths;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _paths = json["paths"];
    if (_paths) {
      msg.paths = _paths;
    }
    return msg;
  }
};

// src/runtime/well-known-types/source_context.pb.ts
var SourceContext2 = {
  encode: function(msg) {
    return SourceContext2._writeMessage(
      msg,
      new BinaryWriter2()
    ).getResultBuffer();
  },
  decode: function(bytes) {
    return SourceContext2._readMessage(
      SourceContext2.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      fileName: ""
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SourceContextJSON2 = {
  encode: function(msg) {
    return JSON.stringify(SourceContextJSON2._writeMessage(msg));
  },
  decode: function(json) {
    return SourceContextJSON2._readMessage(
      SourceContextJSON2.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      fileName: ""
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.fileName) {
      json["fileName"] = msg.fileName;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _fileName = json["fileName"] ?? json["file_name"];
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  }
};

// src/runtime/well-known-types/struct.pb.ts
var NullValue = {
  NULL_VALUE: "NULL_VALUE",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      default: {
        return i;
      }
    }
  }
};
var Struct = {
  encode: function(msg) {
    return Struct._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Struct._readMessage(Struct.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      fields: {}
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.fields).map(([key, value]) => ({
          key,
          value
        })),
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, Struct.Fields._readMessage);
          msg.fields[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
  Fields: {
    _writeMessage: function(msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },
    _readMessage: function(msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = Value.initialize();
            reader.readMessage(msg.value, Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    }
  }
};
var Value = {
  encode: function(msg) {
    return Value._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Value._readMessage(Value.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.nullValue != void 0) {
      writer.writeEnum(1, NullValue._toInt(msg.nullValue));
    }
    if (msg.numberValue != void 0) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != void 0) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != void 0) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != void 0) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != void 0) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValue._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          msg.structValue = Struct.initialize();
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          msg.listValue = ListValue.initialize();
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var ListValue = {
  encode: function(msg) {
    return ListValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      values: []
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values, Value._writeMessage);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var NullValueJSON = {
  NULL_VALUE: "NULL_VALUE",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      default: {
        return i;
      }
    }
  }
};
var StructJSON = {
  encode: function(msg) {
    return JSON.stringify(StructJSON._writeMessage(msg));
  },
  decode: function(json) {
    return StructJSON._readMessage(StructJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      fields: {}
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries(msg.fields).map(([key, value]) => ({ key, value })).map(StructJSON.Fields._writeMessage).map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json["fields"] = fields;
      }
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _fields = json["fields"];
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries(_fields).map(([key, value]) => ({ key, value })).map(StructJSON.Fields._readMessage).map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },
  Fields: {
    _writeMessage: function(msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const value = ValueJSON._writeMessage(msg.value);
        if (Object.keys(value).length > 0) {
          json["value"] = value;
        }
      }
      return json;
    },
    _readMessage: function(msg, json) {
      const _key = json["key"];
      if (_key) {
        msg.key = _key;
      }
      const _value = json["value"];
      if (_value) {
        const m = Value.initialize();
        ValueJSON._readMessage(m, _value);
        msg.value = m;
      }
      return msg;
    }
  }
};
var ValueJSON = {
  encode: function(msg) {
    return JSON.stringify(ValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return ValueJSON._readMessage(ValueJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.nullValue != void 0) {
      json["nullValue"] = msg.nullValue;
    }
    if (msg.numberValue != void 0) {
      json["numberValue"] = msg.numberValue;
    }
    if (msg.stringValue != void 0) {
      json["stringValue"] = msg.stringValue;
    }
    if (msg.boolValue != void 0) {
      json["boolValue"] = msg.boolValue;
    }
    if (msg.structValue != void 0) {
      const structValue = StructJSON._writeMessage(msg.structValue);
      json["structValue"] = structValue;
    }
    if (msg.listValue != void 0) {
      const listValue = ListValueJSON._writeMessage(msg.listValue);
      json["listValue"] = listValue;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _nullValue = json["nullValue"] ?? json["null_value"];
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json["numberValue"] ?? json["number_value"];
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json["stringValue"] ?? json["string_value"];
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json["boolValue"] ?? json["bool_value"];
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json["structValue"] ?? json["struct_value"];
    if (_structValue) {
      const m = Struct.initialize();
      StructJSON._readMessage(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json["listValue"] ?? json["list_value"];
    if (_listValue) {
      const m = ListValue.initialize();
      ListValueJSON._readMessage(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  }
};
var ListValueJSON = {
  encode: function(msg) {
    return JSON.stringify(ListValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return ListValueJSON._readMessage(
      ListValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      values: []
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.values?.length) {
      json["values"] = msg.values.map(ValueJSON._writeMessage);
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _values = json["values"];
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        ValueJSON._readMessage(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  }
};

// src/runtime/well-known-types/timestamp.pb.ts
var Timestamp = {
  encode: function(msg) {
    return Timestamp._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      seconds: 0n,
      nanos: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var TimestampJSON = {
  encode: function(msg) {
    return JSON.stringify(TimestampJSON._writeMessage(msg));
  },
  decode: function(json) {
    return TimestampJSON._readMessage(
      TimestampJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      seconds: 0n,
      nanos: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.seconds) {
      json["seconds"] = msg.seconds.toString();
    }
    if (msg.nanos) {
      json["nanos"] = msg.nanos;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _seconds = json["seconds"];
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json["nanos"];
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  }
};

// src/runtime/well-known-types/type.pb.ts
var Syntax2 = {
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      default: {
        return i;
      }
    }
  }
};
var Type = {
  encode: function(msg) {
    return Type._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Type._readMessage(Type.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax2._fromInt(0)
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options, Option2._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && Syntax2._toInt(msg.syntax)) {
      writer.writeEnum(6, Syntax2._toInt(msg.syntax));
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = Syntax2._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Field = {
  encode: function(msg) {
    return Field._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Field._readMessage(Field.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: ""
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.kind && Field.Kind._toInt(msg.kind)) {
      writer.writeEnum(1, Field.Kind._toInt(msg.kind));
    }
    if (msg.cardinality && Field.Cardinality._toInt(msg.cardinality)) {
      writer.writeEnum(2, Field.Cardinality._toInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options, Option2._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.Kind._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.Cardinality._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
  Kind: {
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    TYPE_DOUBLE: "TYPE_DOUBLE",
    TYPE_FLOAT: "TYPE_FLOAT",
    TYPE_INT64: "TYPE_INT64",
    TYPE_UINT64: "TYPE_UINT64",
    TYPE_INT32: "TYPE_INT32",
    TYPE_FIXED64: "TYPE_FIXED64",
    TYPE_FIXED32: "TYPE_FIXED32",
    TYPE_BOOL: "TYPE_BOOL",
    TYPE_STRING: "TYPE_STRING",
    TYPE_GROUP: "TYPE_GROUP",
    TYPE_MESSAGE: "TYPE_MESSAGE",
    TYPE_BYTES: "TYPE_BYTES",
    TYPE_UINT32: "TYPE_UINT32",
    TYPE_ENUM: "TYPE_ENUM",
    TYPE_SFIXED32: "TYPE_SFIXED32",
    TYPE_SFIXED64: "TYPE_SFIXED64",
    TYPE_SINT32: "TYPE_SINT32",
    TYPE_SINT64: "TYPE_SINT64",
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        default: {
          return i;
        }
      }
    },
    _toInt: function(i) {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        default: {
          return i;
        }
      }
    }
  },
  Cardinality: {
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        default: {
          return i;
        }
      }
    },
    _toInt: function(i) {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        default: {
          return i;
        }
      }
    }
  }
};
var Enum = {
  encode: function(msg) {
    return Enum._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Enum._readMessage(Enum.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax2._fromInt(0)
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.enumvalue,
        EnumValue._writeMessage
      );
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option2._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && Syntax2._toInt(msg.syntax)) {
      writer.writeEnum(5, Syntax2._toInt(msg.syntax));
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = Syntax2._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var EnumValue = {
  encode: function(msg) {
    return EnumValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      name: "",
      number: 0,
      options: []
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option2._writeMessage);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option2.initialize();
          reader.readMessage(m, Option2._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Option2 = {
  encode: function(msg) {
    return Option2._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Option2._readMessage(Option2.initialize(), new BinaryReader2(bytes));
  },
  initialize: function() {
    return {
      name: "",
      value: Any.initialize()
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var SyntaxJSON2 = {
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  _fromInt: function(i) {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      default: {
        return i;
      }
    }
  },
  _toInt: function(i) {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      default: {
        return i;
      }
    }
  }
};
var TypeJSON = {
  encode: function(msg) {
    return JSON.stringify(TypeJSON._writeMessage(msg));
  },
  decode: function(json) {
    return TypeJSON._readMessage(TypeJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax2._fromInt(0)
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.fields?.length) {
      json["fields"] = msg.fields.map(FieldJSON._writeMessage);
    }
    if (msg.oneofs?.length) {
      json["oneofs"] = msg.oneofs;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json["sourceContext"] = sourceContext;
      }
    }
    if (msg.syntax && SyntaxJSON2._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _fields = json["fields"];
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        FieldJSON._readMessage(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json["oneofs"];
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContextJSON._readMessage(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  }
};
var FieldJSON = {
  encode: function(msg) {
    return JSON.stringify(FieldJSON._writeMessage(msg));
  },
  decode: function(json) {
    return FieldJSON._readMessage(FieldJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: ""
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.kind && FieldJSON.Kind._toInt(msg.kind)) {
      json["kind"] = msg.kind;
    }
    if (msg.cardinality && FieldJSON.Cardinality._toInt(msg.cardinality)) {
      json["cardinality"] = msg.cardinality;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json["oneofIndex"] = msg.oneofIndex;
    }
    if (msg.packed) {
      json["packed"] = msg.packed;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.jsonName) {
      json["jsonName"] = msg.jsonName;
    }
    if (msg.defaultValue) {
      json["defaultValue"] = msg.defaultValue;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _kind = json["kind"];
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json["cardinality"];
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json["number"];
    if (_number) {
      msg.number = _number;
    }
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json["oneofIndex"] ?? json["oneof_index"];
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json["packed"];
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json["jsonName"] ?? json["json_name"];
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json["defaultValue"] ?? json["default_value"];
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },
  Kind: {
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    TYPE_DOUBLE: "TYPE_DOUBLE",
    TYPE_FLOAT: "TYPE_FLOAT",
    TYPE_INT64: "TYPE_INT64",
    TYPE_UINT64: "TYPE_UINT64",
    TYPE_INT32: "TYPE_INT32",
    TYPE_FIXED64: "TYPE_FIXED64",
    TYPE_FIXED32: "TYPE_FIXED32",
    TYPE_BOOL: "TYPE_BOOL",
    TYPE_STRING: "TYPE_STRING",
    TYPE_GROUP: "TYPE_GROUP",
    TYPE_MESSAGE: "TYPE_MESSAGE",
    TYPE_BYTES: "TYPE_BYTES",
    TYPE_UINT32: "TYPE_UINT32",
    TYPE_ENUM: "TYPE_ENUM",
    TYPE_SFIXED32: "TYPE_SFIXED32",
    TYPE_SFIXED64: "TYPE_SFIXED64",
    TYPE_SINT32: "TYPE_SINT32",
    TYPE_SINT64: "TYPE_SINT64",
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        default: {
          return i;
        }
      }
    },
    _toInt: function(i) {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        default: {
          return i;
        }
      }
    }
  },
  Cardinality: {
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    _fromInt: function(i) {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        default: {
          return i;
        }
      }
    },
    _toInt: function(i) {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        default: {
          return i;
        }
      }
    }
  }
};
var EnumJSON = {
  encode: function(msg) {
    return JSON.stringify(EnumJSON._writeMessage(msg));
  },
  decode: function(json) {
    return EnumJSON._readMessage(EnumJSON.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax2._fromInt(0)
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.enumvalue?.length) {
      json["enumvalue"] = msg.enumvalue.map(EnumValueJSON._writeMessage);
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json["sourceContext"] = sourceContext;
      }
    }
    if (msg.syntax && SyntaxJSON2._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json["enumvalue"];
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValueJSON._readMessage(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContextJSON._readMessage(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  }
};
var EnumValueJSON = {
  encode: function(msg) {
    return JSON.stringify(EnumValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return EnumValueJSON._readMessage(
      EnumValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      name: "",
      number: 0,
      options: []
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON2._writeMessage);
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _number = json["number"];
    if (_number) {
      msg.number = _number;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option2.initialize();
        OptionJSON2._readMessage(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  }
};
var OptionJSON2 = {
  encode: function(msg) {
    return JSON.stringify(OptionJSON2._writeMessage(msg));
  },
  decode: function(json) {
    return OptionJSON2._readMessage(OptionJSON2.initialize(), JSON.parse(json));
  },
  initialize: function() {
    return {
      name: "",
      value: Any.initialize()
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.value) {
      const value = AnyJSON._writeMessage(msg.value);
      if (Object.keys(value).length > 0) {
        json["value"] = value;
      }
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _value = json["value"];
    if (_value) {
      const m = Any.initialize();
      AnyJSON._readMessage(m, _value);
      msg.value = m;
    }
    return msg;
  }
};

// src/runtime/well-known-types/wrappers.pb.ts
var DoubleValue = {
  encode: function(msg) {
    return DoubleValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var FloatValue = {
  encode: function(msg) {
    return FloatValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Int64Value = {
  encode: function(msg) {
    return Int64Value._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0n
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var UInt64Value = {
  encode: function(msg) {
    return UInt64Value._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0n
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var Int32Value = {
  encode: function(msg) {
    return Int32Value._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var UInt32Value = {
  encode: function(msg) {
    return UInt32Value._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var BoolValue = {
  encode: function(msg) {
    return BoolValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: false
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var StringValue = {
  encode: function(msg) {
    return StringValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return StringValue._readMessage(
      StringValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: ""
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var BytesValue = {
  encode: function(msg) {
    return BytesValue._writeMessage(msg, new BinaryWriter2()).getResultBuffer();
  },
  decode: function(bytes) {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new BinaryReader2(bytes)
    );
  },
  initialize: function() {
    return {
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg, writer) {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },
  _readMessage: function(msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  }
};
var DoubleValueJSON = {
  encode: function(msg) {
    return JSON.stringify(DoubleValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return DoubleValueJSON._readMessage(
      DoubleValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var FloatValueJSON = {
  encode: function(msg) {
    return JSON.stringify(FloatValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return FloatValueJSON._readMessage(
      FloatValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var Int64ValueJSON = {
  encode: function(msg) {
    return JSON.stringify(Int64ValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return Int64ValueJSON._readMessage(
      Int64ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0n
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value.toString();
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  }
};
var UInt64ValueJSON = {
  encode: function(msg) {
    return JSON.stringify(UInt64ValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return UInt64ValueJSON._readMessage(
      UInt64ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0n
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value.toString();
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  }
};
var Int32ValueJSON = {
  encode: function(msg) {
    return JSON.stringify(Int32ValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return Int32ValueJSON._readMessage(
      Int32ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var UInt32ValueJSON = {
  encode: function(msg) {
    return JSON.stringify(UInt32ValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return UInt32ValueJSON._readMessage(
      UInt32ValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: 0
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var BoolValueJSON = {
  encode: function(msg) {
    return JSON.stringify(BoolValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return BoolValueJSON._readMessage(
      BoolValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: false
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var StringValueJSON = {
  encode: function(msg) {
    return JSON.stringify(StringValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return StringValueJSON._readMessage(
      StringValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: ""
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value) {
      json["value"] = msg.value;
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = _value;
    }
    return msg;
  }
};
var BytesValueJSON = {
  encode: function(msg) {
    return JSON.stringify(BytesValueJSON._writeMessage(msg));
  },
  decode: function(json) {
    return BytesValueJSON._readMessage(
      BytesValueJSON.initialize(),
      JSON.parse(json)
    );
  },
  initialize: function() {
    return {
      value: new Uint8Array()
    };
  },
  _writeMessage: function(msg) {
    const json = {};
    if (msg.value?.length) {
      json["value"] = encodeBase64Bytes2(msg.value);
    }
    return json;
  },
  _readMessage: function(msg, json) {
    const _value = json["value"];
    if (_value) {
      msg.value = decodeBase64Bytes2(_value);
    }
    return msg;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Any,
  AnyJSON,
  Api,
  ApiJSON,
  BinaryReader,
  BinaryWriter,
  BoolValue,
  BoolValueJSON,
  BytesValue,
  BytesValueJSON,
  DoubleValue,
  DoubleValueJSON,
  Duration,
  DurationJSON,
  Empty,
  EmptyJSON,
  Enum,
  EnumJSON,
  EnumValue,
  EnumValueJSON,
  Field,
  FieldJSON,
  FieldMask,
  FieldMaskJSON,
  FloatValue,
  FloatValueJSON,
  Int32Value,
  Int32ValueJSON,
  Int64Value,
  Int64ValueJSON,
  ListValue,
  ListValueJSON,
  Method,
  MethodJSON,
  Mixin,
  MixinJSON,
  NullValue,
  NullValueJSON,
  Option,
  OptionJSON,
  SourceContext,
  SourceContextJSON,
  StringValue,
  StringValueJSON,
  Struct,
  StructJSON,
  Syntax,
  SyntaxJSON,
  Timestamp,
  TimestampJSON,
  Type,
  TypeJSON,
  UInt32Value,
  UInt32ValueJSON,
  UInt64Value,
  UInt64ValueJSON,
  Value,
  ValueJSON,
  decodeBase64Bytes,
  encodeBase64Bytes
});
