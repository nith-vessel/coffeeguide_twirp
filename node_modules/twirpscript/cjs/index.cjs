"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  JSONrequest: () => JSONrequest,
  MIN_SUPPORTED_VERSION_0_0_56: () => MIN_SUPPORTED_VERSION_0_0_56,
  PBrequest: () => PBrequest,
  RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION: () => RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION,
  TwirpError: () => TwirpError,
  TwirpErrorResponse: () => TwirpErrorResponse,
  client: () => client,
  createTwirpServer: () => createTwirpServer,
  createTwirpServerless: () => createTwirpServerless
});
module.exports = __toCommonJS(src_exports);

// src/runtime/error/index.ts
var TwirpError = class {
  constructor(error) {
    this.code = error.code;
    this.msg = error.msg;
    this.meta = error.meta;
  }
};
var TwirpIntermediaryError = class extends TwirpError {
  constructor(error) {
    super(error);
  }
};
var statusCodeForErrorCode = {
  canceled: 408,
  unknown: 500,
  invalid_argument: 400,
  malformed: 400,
  deadline_exceeded: 408,
  not_found: 404,
  bad_route: 404,
  already_exists: 409,
  permission_denied: 403,
  unauthenticated: 401,
  resource_exhausted: 403,
  failed_precondition: 412,
  aborted: 409,
  out_of_range: 400,
  unimplemented: 501,
  internal: 500,
  unavailable: 503,
  data_loss: 500
};
function isTwirpError(error) {
  if (typeof error === "object" && error !== null) {
    return "code" in error && error.code in statusCodeForErrorCode;
  }
  return false;
}
function errorCodeFromStatusCode(status) {
  if (300 >= status && status <= 400) {
    return "internal";
  }
  const statusError = {
    401: "unauthenticated",
    403: "permission_denied",
    404: "bad_route",
    429: "unavailable",
    502: "unavailable",
    503: "unavailable",
    504: "unavailable"
  };
  return statusError[status] ?? "internal";
}
async function twirpErrorFromResponse(res) {
  const text = await res.text();
  try {
    const json = JSON.parse(text);
    if (isTwirpError(json)) {
      return new TwirpError(json);
    }
  } catch {
  }
  return new TwirpIntermediaryError({
    code: errorCodeFromStatusCode(res.status),
    msg: "HTTP Error from Intermediary Proxy",
    meta: {
      http_error_from_intermediary: "true",
      status_code: res.status.toString(),
      body: text,
      location: res.headers.get("location") ?? void 0
    }
  });
}

// src/runtime/eventEmitter/index.ts
function createEventEmitter() {
  const listeners = {};
  return {
    on: (eventName, listener) => {
      listeners[eventName] ?? (listeners[eventName] = []);
      listeners[eventName]?.push(listener);
    },
    off: (eventName, listener) => {
      listeners[eventName] = listeners[eventName]?.filter(
        (x) => x !== listener
      );
    },
    emit: (eventName, ...args) => {
      listeners[eventName]?.forEach((cb) => {
        cb(...args);
      });
    }
  };
}

// src/runtime/client/index.ts
var clientMiddleware = [];
var ee = createEventEmitter();
var fetchTransport = async (url, opts) => {
  return fetch(url, opts);
};
var client = {
  baseURL: "",
  headers: {},
  prefix: "/twirp",
  use(middleware) {
    clientMiddleware.push(middleware);
    return client;
  },
  on: (...args) => {
    ee.on(...args);
    return client;
  },
  off: (...args) => {
    ee.off(...args);
    return client;
  },
  rpcTransport: fetchTransport
};
async function runMiddleware(config, request) {
  let cfg = config;
  let idx = 1;
  const middleware = [...clientMiddleware, request];
  try {
    return await middleware[0](config, function next(c) {
      cfg = c;
      const nxt = middleware[idx];
      idx++;
      return nxt(c, next);
    });
  } catch (e) {
    const error = e instanceof TwirpError ? e : new TwirpError({
      code: "internal",
      msg: "client error"
    });
    ee.emit("error", cfg, error);
    throw e;
  }
}
function mergeConfig(config = {}, path) {
  const baseURL = config.baseURL ?? client.baseURL ?? "";
  const prefix = config.prefix ?? client.prefix ?? "";
  const url = baseURL + prefix + path;
  const rpcTransport = config.rpcTransport ?? client.rpcTransport;
  return {
    url,
    headers: {
      ...client.headers,
      ...config.headers
    },
    rpcTransport
  };
}
async function makeRequest(contentType, path, body, config) {
  return runMiddleware(
    mergeConfig(config, path),
    async (c) => {
      ee.emit("requestPrepared", c);
      const res = await c.rpcTransport(c.url, {
        method: "POST",
        headers: {
          accept: contentType,
          "content-type": contentType,
          ...c.headers
        },
        body
      });
      ee.emit("responseReceived", c);
      if (!res.ok) {
        throw await twirpErrorFromResponse(res);
      }
      switch (contentType) {
        case "application/protobuf": {
          const buffer = await res.arrayBuffer();
          return new Uint8Array(buffer);
        }
        case "application/json": {
          return res.text();
        }
        default: {
          const _exhaust = contentType;
          return _exhaust;
        }
      }
    }
  );
}
function JSONrequest(path, body, config) {
  return makeRequest("application/json", path, body, config);
}
function PBrequest(path, body, config) {
  return makeRequest(
    "application/protobuf",
    path,
    body,
    config
  );
}

// src/runtime/server/requestLogging/index.ts
var timingField = "__twirpRequestStartMs__";
function withRequestLogging(app) {
  app.on("requestReceived", (ctx, request) => {
    ctx[timingField] = Date.now();
    console.info(`[TwirpScript] Started ${request.method} "${request.url}"`);
  });
  app.on("requestRouted", (ctx) => {
    console.info(
      `[TwirpScript] Processing by ${ctx.service?.name}#${ctx.method?.name} as ${ctx.contentType}`
    );
  });
  app.on("responseSent", (ctx, response) => {
    const time = Date.now() - ctx[timingField];
    console.info(
      `[TwirpScript] Completed ${response.statusCode} in ${time} ms.`
    );
  });
  app.on("error", (_ctx, error) => {
    console.error("[TwirpScript] Error:");
    console.error(error);
  });
  return app;
}

// src/runtime/server/index.ts
var TWIRPSCRIPT_INVARIANT = "TwirpScript Invariant";
function TwirpErrorResponse(error) {
  return {
    statusCode: statusCodeForErrorCode[error.code],
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify(error)
  };
}
async function executeServiceMethod(method, req, context, ee2) {
  switch (context.contentType) {
    case "JSON": {
      let body;
      try {
        const utf8 = new TextDecoder().decode(req.body);
        body = method.input.json.decode(utf8);
      } catch (e) {
        throw new TwirpError({
          code: "invalid_argument",
          msg: "failed to deserialize argument as JSON"
        });
      }
      ee2.emit("requestRouted", context, body);
      const response = await method.handler(body, context);
      ee2.emit("responsePrepared", context, response);
      return method.output.json.encode(response);
    }
    case "Protobuf": {
      let body;
      try {
        body = method.input.protobuf.decode(req.body);
      } catch (e) {
        throw new TwirpError({
          code: "invalid_argument",
          msg: "failed to deserialize argument as Protobuf"
        });
      }
      ee2.emit("requestRouted", context, body);
      const response = await method.handler(body, context);
      ee2.emit("responsePrepared", context, response);
      return method.output.protobuf.encode(response);
    }
    case "Unknown": {
      throw new Error(TWIRPSCRIPT_INVARIANT);
    }
    default: {
      const _exhaust = context.contentType;
      throw new Error(TWIRPSCRIPT_INVARIANT + _exhaust);
    }
  }
}
function validateRequest(req) {
  if (!req.url) {
    return new TwirpError({
      code: "malformed",
      msg: "no request url provided"
    });
  }
  if (!req.method) {
    return new TwirpError({
      code: "malformed",
      msg: "no request method provided"
    });
  }
  if (req.method !== "POST") {
    return new TwirpError({
      code: "malformed",
      msg: `unexpected request method ${req.method}`
    });
  }
  const contentType = req.headers["content-type"];
  if (!contentType) {
    return new TwirpError({
      code: "malformed",
      msg: "no request content-type provided"
    });
  }
  if (contentType !== "application/json" && contentType !== "application/protobuf") {
    return new TwirpError({
      code: "malformed",
      msg: `unexpected request content-type ${contentType}`
    });
  }
}
function handleError(error, ctx, ee2) {
  ee2.emit("error", ctx, error);
  return TwirpErrorResponse(error);
}
function handleUserSpaceError(error, ctx, ee2) {
  if (error instanceof TwirpError) {
    return handleError(error, ctx, ee2);
  } else {
    ee2.emit(
      "error",
      ctx,
      new TwirpError({
        code: "internal",
        msg: "server error",
        meta: { error }
      })
    );
    return TwirpErrorResponse(
      new TwirpError({
        code: "internal",
        msg: "server error"
      })
    );
  }
}
function twirpHandler(ee2) {
  return async (req, ctx) => {
    const err = validateRequest(req);
    if (err) {
      return handleError(err, ctx, ee2);
    }
    const handler = ctx.method;
    if (!handler) {
      return handleError(
        new TwirpError({
          code: "bad_route",
          msg: `no handler for path POST ${req.url}.`
        }),
        ctx,
        ee2
      );
    }
    try {
      const response = await executeServiceMethod(handler, req, ctx, ee2);
      return {
        statusCode: 200,
        headers: {
          "content-type": req.headers["content-type"]
        },
        body: response
      };
    } catch (error) {
      return handleUserSpaceError(error, ctx, ee2);
    }
  };
}
function getContentType(contentType) {
  switch (contentType) {
    case "application/json":
      return "JSON";
    case "application/protobuf":
      return "Protobuf";
    default:
      return "Unknown";
  }
}
function getRequestContext(req, services, config) {
  const ctx = {
    service: void 0,
    method: void 0,
    contentType: getContentType(req.headers["content-type"])
  };
  const prefix = config.prefix + "/";
  const startsWithPrefix = req.url.startsWith(prefix);
  if (!startsWithPrefix) {
    return ctx;
  }
  const methodIdx = req.url.lastIndexOf("/");
  const serviceName = req.url.slice(prefix.length, methodIdx);
  const serviceMethod = req.url.slice(methodIdx + 1);
  const service = services.find((service2) => service2.name === serviceName);
  const handler = service?.methods[serviceMethod];
  if (handler) {
    ctx.service = service;
    ctx.method = handler;
  }
  return ctx;
}
function createTwirpServerless(services, config = {}) {
  const configWithDefaults = {
    debug: true,
    prefix: "/twirp",
    ...config
  };
  const serverMiddleware = [];
  const ee2 = createEventEmitter();
  const twirp = twirpHandler(ee2);
  async function app(req) {
    const ctx = getRequestContext(
      req,
      services,
      configWithDefaults
    );
    ee2.emit("requestReceived", ctx, req);
    let response;
    let idx = 1;
    const middleware = [...serverMiddleware, twirp];
    try {
      response = await middleware[0](req, ctx, function next() {
        const nxt = middleware[idx];
        idx++;
        return nxt(req, ctx, next);
      });
    } catch (error) {
      response = handleUserSpaceError(error, ctx, ee2);
    }
    ee2.emit("responseSent", ctx, response);
    return response;
  }
  app.use = (handler) => {
    serverMiddleware.push(handler);
    return app;
  };
  app.on = (...args) => {
    ee2.on(...args);
    return app;
  };
  app.off = (...args) => {
    ee2.off(...args);
    return app;
  };
  if (configWithDefaults.debug !== false) {
    withRequestLogging(app);
  }
  return app;
}
async function getBody(req) {
  const buffers = [];
  for await (const chunk of req) {
    buffers.push(chunk);
  }
  const length = buffers.reduce((acc, buffer) => acc + buffer.length, 0);
  const body = new Uint8Array(length);
  let offset = 0;
  buffers.forEach((buffer) => {
    body.set(buffer, offset);
    offset += buffer.length;
  });
  return body;
}
function createTwirpServer(services, config = {}) {
  const _app = createTwirpServerless(services, config);
  async function app(req, res) {
    const body = await getBody(req);
    const request = req;
    request.body = body;
    const response = await _app(request);
    res.writeHead(response.statusCode, response.headers);
    res.end(response.body);
  }
  app.use = (handler) => {
    _app.use(handler);
    return app;
  };
  app.on = (...args) => {
    _app.on(...args);
    return app;
  };
  app.off = (...args) => {
    _app.off(...args);
    return app;
  };
  return app;
}

// src/runtime/compatCheck.ts
var RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION = "MIN_SUPPORTED_VERSION_0_0_56";
var MIN_SUPPORTED_VERSION_0_0_56 = RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  JSONrequest,
  MIN_SUPPORTED_VERSION_0_0_56,
  PBrequest,
  RUNTIME_MIN_CODE_GEN_SUPPORTED_VERSION,
  TwirpError,
  TwirpErrorResponse,
  client,
  createTwirpServer,
  createTwirpServerless
});
