import { TwirpError } from "../error/index.js";
import { Emitter } from "../eventEmitter/index.js";
import type { ByteSource } from "protoscript";
export interface Response {
    body: string | Uint8Array;
    headers: {
        [key: string]: string | undefined;
    };
    statusCode: number;
}
export interface Request {
    body: Uint8Array;
    headers: {
        [key: string]: string | undefined;
    };
    url: string;
}
export interface InboundRequest extends Request {
    method: string;
}
interface ServerResponse {
    end: (chunk: any, cb?: () => void) => void;
    writeHead: (statusCode: number, headers?: ServerRequest["headers"]) => void;
}
interface ServerRequest {
    headers: Record<string, string | string[] | undefined>;
    method?: string | undefined;
    url?: string | undefined;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
}
declare type ServerRequestWithBody<SR extends ServerRequest> = SR & Pick<Request, "body">;
declare type ServiceContext<S extends readonly Service[]> = {
    [Idx in keyof S]: {
        service: S[Idx];
        method: NonNullable<S[Idx]["methods"][keyof S[Idx]["methods"]]>;
    };
}[number] | {
    service: undefined;
    method: undefined;
};
/**
 * The requested content-type for the request.
 */
declare type ContentType = "JSON" | "Protobuf" | "Unknown";
export declare type TwirpContext<ContextExt = unknown, Services extends readonly Service[] = Service[]> = {
    contentType: ContentType;
} & ServiceContext<Services> & ContextExt;
interface Message<T> {
    protobuf: {
        encode: (message: T) => Uint8Array;
        decode: (bytes: ByteSource) => T;
    };
    json: {
        encode: (message: T) => string;
        decode: (str: string) => T;
    };
}
export interface ServiceMethod<Context = any> {
    name: string;
    handler: (input: any, ctx: Context) => any;
    input: Message<any>;
    output: Message<any>;
}
export interface Service {
    name: string;
    methods: Record<string, ServiceMethod | undefined>;
}
export declare function TwirpErrorResponse(error: TwirpError): Response;
export declare function executeServiceMethod<Context extends TwirpContext>(method: ServiceMethod, req: Request, context: Context, ee: Emitter<ServerHooks<Context, Request>>): Promise<string | Uint8Array>;
declare type Next = () => Promise<Response>;
interface TwirpServerConfig {
    /**
     * Puts the Twirp server runtime into debug mode when set to true. This enables request logging. Defaults to true.
     */
    debug?: boolean;
    /**
     * A path prefix such as "/my/custom/prefix". Defaults to "/twirp", but can be set to "".
     */
    prefix?: string;
}
export declare type Middleware<Context = unknown, Request = unknown> = (request: Request, context: TwirpContext<Context>, next: Next) => Promise<Response>;
export declare function twirpHandler<Context extends TwirpContext>(ee: Emitter<ServerHooks<Context, Request>>): (req: InboundRequest, ctx: Context) => Promise<Response>;
declare type ContextMethod<Context extends TwirpContext> = Exclude<Context["method"], undefined>;
export declare type ServerHooks<Context extends TwirpContext, Request> = {
    requestReceived: (context: Context, request: Request) => void;
    requestRouted: (context: Context, input: ReturnType<ContextMethod<Context>["input"]["protobuf"]["decode"]>) => void;
    responsePrepared: (context: Context, output: ReturnType<ContextMethod<Context>["output"]["protobuf"]["decode"]>) => void;
    responseSent: (context: Context, response: Response) => void;
    error: (context: Context, error: TwirpError) => void;
};
export interface TwirpServerRuntime<Context extends TwirpContext = TwirpContext, Request = InboundRequest> {
    /**
     * Registers middleware to manipulate the server request / response lifecycle.
     *
     * The middleware handler will receive `request`, `context` and `next` parameters. `request` is the incoming request. `context` is a request context object which will be passed to each middleware handler and finally the Twirp service handler you implemented. `context` enables you to pass extra parameters to your service handlers that are not available via your service's defined request parameters, and can be used to implement things such as authentication or rate limiting. `next` invokes the next handler in the chain -- either the next registered middleware, or the Twirp service handler you implemented.
     *
     * Middleware is called in order of registration, with the Twirp service handler you implemented invoked last.
     */
    use: (middleware: Middleware<Context, Request>) => this;
    /**
     * Registers event handler that can instrument a Twirp-generated server. These callbacks all accept the current request `context` as their first argument.
     *
     * `requestReceived` is called as soon as a request enters the Twirp server at the earliest available moment. Called with the current `context` and the request.
     *
     * `requestRouted` is called when a request has been routed to a service method. Called with the current `context` and the input to the service method.
     *
     * `responsePrepared` is called when a request has been handled by a service method. Called with the current `context` and the response generated by the service method.
     *
     * `responseSent` is called when all bytes of a response (including an error response) have been written. Called with the current `context` and the response.
     *
     * `error` is called when an error occurs while handling a request. Called with the current `context` and the error that occurred.
     *
     */
    on: <Event extends keyof ServerHooks<Context, Request>>(event: Event, handler: ServerHooks<Context, Request>[Event]) => this;
    /**
     * Removes a registered event handler.
     */
    off: <Event extends keyof ServerHooks<Context, Request>>(event: Event, handler: ServerHooks<Context, Request>[Event]) => this;
}
interface TwirpServer<Context extends TwirpContext, Request extends ServerRequest> extends TwirpServerRuntime<Context, ServerRequestWithBody<Request>> {
    (req: Request, res: ServerResponse): void;
}
interface TwirpServerless<Context extends TwirpContext, Request> extends TwirpServerRuntime<Context, Request> {
    (req: Request): Promise<Response>;
}
export declare function createTwirpServerless<ContextExt, Services extends readonly Service[], Request extends InboundRequest = InboundRequest>(services: Services, config?: TwirpServerConfig): TwirpServerless<TwirpContext<ContextExt, typeof services>, Request>;
export declare function createTwirpServer<ContextExt, Services extends readonly Service[], Request extends ServerRequest = ServerRequest>(services: Services, config?: TwirpServerConfig): TwirpServer<TwirpContext<ContextExt, typeof services>, Request>;
export {};
