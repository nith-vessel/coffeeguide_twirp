import { TwirpError, statusCodeForErrorCode } from "../error/index.js";
import { createEventEmitter } from "../eventEmitter/index.js";
import { withRequestLogging } from "./requestLogging/index.js";
/**
 * This should never occur.
 *
 * If this error is encountered, please open an issue:
 * https://github.com/tatethurston/TwirpScript/issues/new
 */
const TWIRPSCRIPT_INVARIANT = "TwirpScript Invariant";
export function TwirpErrorResponse(error) {
    return {
        statusCode: statusCodeForErrorCode[error.code],
        headers: {
            "content-type": "application/json",
        },
        body: JSON.stringify(error),
    };
}
export async function executeServiceMethod(method, req, context, ee) {
    switch (context.contentType) {
        case "JSON": {
            let body;
            try {
                const utf8 = new TextDecoder().decode(req.body);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                body = method.input.json.decode(utf8);
            }
            catch (e) {
                throw new TwirpError({
                    code: "invalid_argument",
                    msg: "failed to deserialize argument as JSON",
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            ee.emit("requestRouted", context, body);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const response = await method.handler(body, context);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            ee.emit("responsePrepared", context, response);
            return method.output.json.encode(response);
        }
        case "Protobuf": {
            let body;
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion
                body = method.input.protobuf.decode(req.body);
            }
            catch (e) {
                throw new TwirpError({
                    code: "invalid_argument",
                    msg: "failed to deserialize argument as Protobuf",
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            ee.emit("requestRouted", context, body);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const response = await method.handler(body, context);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            ee.emit("responsePrepared", context, response);
            return method.output.protobuf.encode(response);
        }
        // This should never occur because we've processed the content type in
        // validateRequest
        // istanbul ignore: invariant
        case "Unknown": {
            throw new Error(TWIRPSCRIPT_INVARIANT);
        }
        // This should never occur because we've processed the content type in
        // validateRequest
        // istanbul ignore: invariant
        default: {
            const _exhaust = context.contentType;
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            throw new Error(TWIRPSCRIPT_INVARIANT + _exhaust);
        }
    }
}
function validateRequest(req) {
    if (!req.url) {
        return new TwirpError({
            code: "malformed",
            msg: "no request url provided",
        });
    }
    if (!req.method) {
        return new TwirpError({
            code: "malformed",
            msg: "no request method provided",
        });
    }
    if (req.method !== "POST") {
        return new TwirpError({
            code: "malformed",
            msg: `unexpected request method ${req.method}`,
        });
    }
    const contentType = req.headers["content-type"];
    if (!contentType) {
        return new TwirpError({
            code: "malformed",
            msg: "no request content-type provided",
        });
    }
    if (contentType !== "application/json" &&
        contentType !== "application/protobuf") {
        return new TwirpError({
            code: "malformed",
            msg: `unexpected request content-type ${contentType}`,
        });
    }
}
function handleError(error, ctx, ee) {
    ee.emit("error", ctx, error);
    return TwirpErrorResponse(error);
}
function handleUserSpaceError(error, ctx, ee) {
    if (error instanceof TwirpError) {
        return handleError(error, ctx, ee);
    }
    else {
        ee.emit("error", ctx, new TwirpError({
            code: "internal",
            msg: "server error",
            // Do expose internal error message in reporting
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
            meta: { error: error },
        }));
        // Don't expose internal error message in response
        return TwirpErrorResponse(new TwirpError({
            code: "internal",
            msg: "server error",
        }));
    }
}
export function twirpHandler(ee) {
    return async (req, ctx) => {
        const err = validateRequest(req);
        if (err) {
            return handleError(err, ctx, ee);
        }
        const handler = ctx.method;
        if (!handler) {
            return handleError(new TwirpError({
                code: "bad_route",
                msg: `no handler for path POST ${req.url}.`,
            }), ctx, ee);
        }
        try {
            const response = await executeServiceMethod(handler, req, ctx, ee);
            return {
                statusCode: 200,
                headers: {
                    "content-type": req.headers["content-type"],
                },
                body: response,
            };
        }
        catch (error) {
            return handleUserSpaceError(error, ctx, ee);
        }
    };
}
function getContentType(contentType) {
    switch (contentType) {
        case "application/json":
            return "JSON";
        case "application/protobuf":
            return "Protobuf";
        default:
            return "Unknown";
    }
}
function getRequestContext(req, services, config) {
    const ctx = {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment , @typescript-eslint/no-explicit-any
        service: undefined,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment , @typescript-eslint/no-explicit-any
        method: undefined,
        contentType: getContentType(req.headers["content-type"]),
    };
    const prefix = config.prefix + "/";
    const startsWithPrefix = req.url.startsWith(prefix);
    if (!startsWithPrefix) {
        return ctx;
    }
    const methodIdx = req.url.lastIndexOf("/");
    const serviceName = req.url.slice(prefix.length, methodIdx);
    const serviceMethod = req.url.slice(methodIdx + 1);
    const service = services.find((service) => service.name === serviceName);
    const handler = service?.methods[serviceMethod];
    if (handler) {
        ctx.service = service;
        ctx.method = handler;
    }
    return ctx;
}
export function createTwirpServerless(services, config = {}) {
    const configWithDefaults = {
        debug: true,
        prefix: "/twirp",
        ...config,
    };
    const serverMiddleware = [];
    const ee = createEventEmitter();
    const twirp = twirpHandler(ee);
    async function app(req) {
        const ctx = getRequestContext(req, services, configWithDefaults);
        ee.emit("requestReceived", ctx, req);
        let response;
        let idx = 1;
        const middleware = [...serverMiddleware, twirp];
        try {
            response = await middleware[0](req, ctx, function next() {
                const nxt = middleware[idx];
                idx++;
                return nxt(req, ctx, next);
            });
        }
        catch (error) {
            response = handleUserSpaceError(error, ctx, ee);
        }
        ee.emit("responseSent", ctx, response);
        return response;
    }
    app.use = (handler) => {
        serverMiddleware.push(handler);
        return app;
    };
    app.on = (...args) => {
        ee.on(...args);
        return app;
    };
    app.off = (...args) => {
        ee.off(...args);
        return app;
    };
    if (configWithDefaults.debug !== false) {
        withRequestLogging(app);
    }
    return app;
}
async function getBody(req) {
    const buffers = [];
    for await (const chunk of req) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        buffers.push(chunk);
    }
    const length = buffers.reduce((acc, buffer) => acc + buffer.length, 0);
    const body = new Uint8Array(length);
    let offset = 0;
    buffers.forEach((buffer) => {
        body.set(buffer, offset);
        offset += buffer.length;
    });
    return body;
}
export function createTwirpServer(services, config = {}) {
    const _app = createTwirpServerless(services, config);
    async function app(req, res) {
        const body = await getBody(req);
        const request = req;
        request.body = body;
        const response = await _app(request);
        res.writeHead(response.statusCode, response.headers);
        res.end(response.body);
    }
    app.use = (handler) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any , @typescript-eslint/no-unsafe-argument
        _app.use(handler);
        return app;
    };
    app.on = (...args) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _app.on(...args);
        return app;
    };
    app.off = (...args) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _app.off(...args);
        return app;
    };
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    return app;
}
