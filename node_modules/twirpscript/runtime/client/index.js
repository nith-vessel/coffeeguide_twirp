import { TwirpError, twirpErrorFromResponse } from "../error/index.js";
import { createEventEmitter } from "../eventEmitter/index.js";
const clientMiddleware = [];
const ee = createEventEmitter();
const fetchTransport = async (url, opts) => {
    return fetch(url, opts);
};
/**
 * Global configuration for the TwirpScript clients.
 */
export const client = {
    baseURL: "",
    headers: {},
    prefix: "/twirp",
    use(middleware) {
        clientMiddleware.push(middleware);
        return client;
    },
    on: (...args) => {
        ee.on(...args);
        return client;
    },
    off: (...args) => {
        ee.off(...args);
        return client;
    },
    rpcTransport: fetchTransport,
};
async function runMiddleware(config, request) {
    // outer scope for error event callback arg
    let cfg = config;
    let idx = 1;
    const middleware = [...clientMiddleware, request];
    try {
        return await middleware[0](config, function next(c) {
            cfg = c;
            const nxt = middleware[idx];
            idx++;
            return nxt(c, next);
        });
    }
    catch (e) {
        const error = e instanceof TwirpError
            ? e
            : new TwirpError({
                code: "internal",
                msg: "client error",
            });
        ee.emit("error", cfg, error);
        throw e;
    }
}
function mergeConfig(config = {}, path) {
    const baseURL = config.baseURL ?? client.baseURL ?? "";
    const prefix = config.prefix ?? client.prefix ?? "";
    const url = baseURL + prefix + path;
    const rpcTransport = config.rpcTransport ?? client.rpcTransport;
    return {
        url,
        headers: {
            ...client.headers,
            ...config.headers,
        },
        rpcTransport,
    };
}
async function makeRequest(contentType, path, body, config) {
    return runMiddleware(mergeConfig(config, path), async (c) => {
        ee.emit("requestPrepared", c);
        const res = await c.rpcTransport(c.url, {
            method: "POST",
            headers: {
                accept: contentType,
                "content-type": contentType,
                ...c.headers,
            },
            body,
        });
        ee.emit("responseReceived", c);
        if (!res.ok) {
            throw await twirpErrorFromResponse(res);
        }
        switch (contentType) {
            case "application/protobuf": {
                const buffer = await res.arrayBuffer();
                return new Uint8Array(buffer);
            }
            case "application/json": {
                return res.text();
            }
            default: {
                const _exhaust = contentType;
                return _exhaust;
            }
        }
    });
}
export function JSONrequest(path, body, config) {
    return makeRequest("application/json", path, body, config);
}
export function PBrequest(path, body, config) {
    return makeRequest("application/protobuf", path, body, config);
}
